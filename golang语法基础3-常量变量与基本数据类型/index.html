<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Golang语法基础3-常量、变量与基本数据类型 - Cloud1998's blog</title><meta name=Description content="这是我的全新 Hugo 网站"><meta property="og:title" content="Golang语法基础3-常量、变量与基本数据类型"><meta property="og:description" content="本文介绍 Go 中的常量、变量、变量的作用域、变量的声明与赋值、变量的简短赋值、基本数据类型和 init 函数。"><meta property="og:type" content="article"><meta property="og:url" content="http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><meta property="og:image" content="http://Cloud1998.github.io/logo.png"><meta property="article:published_time" content="2023-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-05T00:00:00+00:00"><meta property="og:site_name" content="我的网站"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://Cloud1998.github.io/logo.png"><meta name=twitter:title content="Golang语法基础3-常量、变量与基本数据类型"><meta name=twitter:description content="本文介绍 Go 中的常量、变量、变量的作用域、变量的声明与赋值、变量的简短赋值、基本数据类型和 init 函数。"><meta name=application-name content="我的网站"><meta name=apple-mobile-web-app-title content="我的网站"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><link rel=prev href=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础3-常量、变量与基本数据类型","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/Cloud1998.github.io\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\/"},"genre":"posts","keywords":"Golang语法基础","wordcount":4770,"url":"http:\/\/Cloud1998.github.io\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\/","datePublished":"2023-02-05T00:00:00+00:00","dateModified":"2023-02-05T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Ge Yunfei"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Cloud1998's blog">Cloud1998's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Cloud1998's blog">Cloud1998's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Golang语法基础3-常量、变量与基本数据类型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Ge Yunfei</a></span>&nbsp;<span class=post-category>included in <a href=/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw" aria-hidden=true></i>编程技术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-02-05>2023-02-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4770 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;10 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-常量>1. 常量</a></li><li><a href=#2-变量>2. 变量</a><ul><li><ul><li><a href=#作用域>作用域</a></li><li><a href=#声明与赋值>声明与赋值</a></li><li><a href=#简短赋值>简短赋值</a></li></ul></li></ul></li><li><a href=#3-值类型和引用类型>3. 值类型和引用类型</a></li><li><a href=#4-init函数>4. init函数</a></li></ul></nav></div></div><div class=content id=content><p>本文介绍 Go 中的常量、变量、变量的作用域、变量的声明与赋值、变量的简短赋值、基本数据类型和 init 函数。</p><h2 id=1-常量>1. 常量</h2><p>常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：<code>const identifier [type] = value</code>，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=nx>Pi</span> <span class=p>=</span> <span class=mf>3.14159</span>
</code></pre></td></tr></table></div></div><p>在 Go 语言中，你可以省略类型说明符 <code>[type]</code>，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义： <code>const b string = "abc"</code></li><li>隐式类型定义： <code>const b = "abc"</code></li></ul><p>一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>n</span> <span class=kt>int</span>
<span class=nf>f</span><span class=p>(</span><span class=nx>n</span> <span class=o>+</span> <span class=mi>5</span><span class=p>)</span>	<span class=c1>// 无类型的数字型常量 “5” 它的类型在这里变成了 int
</span></code></pre></td></tr></table></div></div><p>常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p><ul><li>正确的做法：<code>const c1 = 2 / 3</code></li><li>错误的做法：<code>const c2 = getNumber()</code> // 引发构建错误: <code>getNumber() used as value</code></li></ul><p><strong>因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：<code>len()</code>。</strong></p><p>数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=nx>Ln2</span> <span class=p>=</span> <span class=mf>0.693147180559945309417232121458</span>\
			<span class=mi>176568075500134360255254120680009</span>
<span class=kd>const</span> <span class=nx>Log2E</span> <span class=p>=</span> <span class=mi>1</span><span class=o>/</span><span class=nx>Ln2</span> <span class=c1>// this is a precise reciprocal
</span><span class=c1></span><span class=kd>const</span> <span class=nx>Billion</span> <span class=p>=</span> <span class=mf>1e9</span> <span class=c1>// float constant
</span><span class=c1></span><span class=kd>const</span> <span class=nx>hardEight</span> <span class=p>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>100</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>97</span>
</code></pre></td></tr></table></div></div><p>根据上面的例子我们可以看到，反斜杠 <code>\</code> 可以在常量表达式中作为多行的连接符使用。</p><p>与各种类型的数字型变量相比，你无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。</p><p>不过需要注意的是，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。另外，常量也允许使用并行赋值的形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=nx>beef</span><span class=p>,</span> <span class=nx>two</span><span class=p>,</span> <span class=nx>c</span> <span class=p>=</span> <span class=s>&#34;eat&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=s>&#34;veg&#34;</span>
<span class=kd>const</span> <span class=nx>Monday</span><span class=p>,</span> <span class=nx>Tuesday</span><span class=p>,</span> <span class=nx>Wednesday</span><span class=p>,</span> <span class=nx>Thursday</span><span class=p>,</span> <span class=nx>Friday</span><span class=p>,</span> <span class=nx>Saturday</span><span class=p>,</span> <span class=nx>Sunday</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span>
<span class=kd>const</span> <span class=p>(</span>
	<span class=nx>Monday</span><span class=p>,</span> <span class=nx>Tuesday</span><span class=p>,</span> <span class=nx>Wednesday</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span>
  <span class=nx>Thursday</span><span class=p>,</span> <span class=nx>Friday</span><span class=p>,</span> <span class=nx>Saturday</span> <span class=p>=</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span>
  <span class=nx>Sunday</span> <span class=p>=</span> <span class=mi>7</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>常量还可以用作枚举：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>Unknow</span> <span class=p>=</span> <span class=mi>0</span>
  <span class=nx>Female</span> <span class=p>=</span> <span class=mi>1</span>
  <span class=nx>Male</span> <span class=p>=</span> <span class=mi>2</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>现在，数字 <code>0</code>、<code>1</code> 和 <code>2</code> 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值，比如使用 switch/case 结构。</p><p>在这个例子中，<code>iota</code> 可以被用作枚举值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>a</span> <span class=p>=</span> <span class=kc>iota</span>
  <span class=nx>b</span> <span class=p>=</span> <span class=kc>iota</span>
  <span class=nx>c</span> <span class=p>=</span> <span class=kc>iota</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>第一个 <code>iota</code> 等于 0，每当 <code>iota</code> 在<strong>新的一行</strong>被使用时，它的值都会自动加 1。并且没有赋值的常量默认会应用上一行的赋值表达式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式
</span><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>a</span> <span class=p>=</span> <span class=kc>iota</span>	<span class=c1>// a = 0
</span><span class=c1></span>  <span class=nx>b</span>					<span class=c1>// b = 1
</span><span class=c1></span>  <span class=nx>c</span>					<span class=c1>// c = 2
</span><span class=c1></span>  <span class=nx>d</span> <span class=p>=</span> <span class=mi>5</span>			<span class=c1>// d = 5
</span><span class=c1></span>  <span class=nx>e</span>					<span class=c1>// e = 5
</span><span class=c1></span><span class=p>)</span>

<span class=c1>// 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次
</span><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>Apple</span><span class=p>,</span> <span class=nx>Banana</span> <span class=p>=</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>2</span>	<span class=c1>// Apple = 1 Banana = 2
</span><span class=c1></span>  <span class=nx>Cherimoya</span><span class=p>,</span> <span class=nx>Durian</span>                  <span class=c1>// Cherimoya = 2 Durian = 3
</span><span class=c1></span>  <span class=nx>Elderberry</span><span class=p>,</span> <span class=nx>Fig</span>                    <span class=c1>// Elderberry = 3, Fig = 4
</span><span class=c1></span><span class=p>)</span>

<span class=c1>// 使用 iota 结合 位运算 表示资源状态的使用案例
</span><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>Open</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=kc>iota</span>	<span class=c1>// 0001
</span><span class=c1></span>  <span class=nx>Close</span>							<span class=c1>// 0010
</span><span class=c1></span>  <span class=nx>Pending</span>						<span class=c1>// 0100
</span><span class=c1></span><span class=p>)</span>

<span class=kd>const</span> <span class=p>(</span>
	<span class=nx>_</span> <span class=p>=</span> <span class=kc>iota</span>							<span class=c1>// 使用 _ 忽略不需要的 iota
</span><span class=c1></span>  <span class=nx>KB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>	<span class=c1>// 1 &lt;&lt; (10*1)
</span><span class=c1></span>  <span class=nx>MB</span>										<span class=c1>// 1 &lt;&lt; (10*2)
</span><span class=c1></span>  <span class=nx>GB</span>										<span class=c1>// 1 &lt;&lt; (10*3)
</span><span class=c1></span>  <span class=nx>TB</span>										<span class=c1>// 1 &lt;&lt; (10*4)
</span><span class=c1></span>  <span class=nx>PB</span>										<span class=c1>// 1 &lt;&lt; (10*5)
</span><span class=c1></span>  <span class=nx>EB</span>										<span class=c1>// 1 &lt;&lt; (10*6)
</span><span class=c1></span>  <span class=nx>ZB</span>										<span class=c1>// 1 &lt;&lt; (10*7)
</span><span class=c1></span>  <span class=nx>YB</span>										<span class=c1>// 1 &lt;&lt; (10*8)
</span><span class=c1></span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>关于 <code>iota</code> 的使用涉及到非常复杂多样的情况，这里解释的并不清晰，因为很难对 <code>iota</code> 的用法进行直观的文字描述。如希望进一步了解，请观看视频教程 <a href=https://github.com/Unknwon/go-fundamental-programming target=_blank rel="noopener noreffer">《Go编程基础》</a> <a href=https://github.com/Unknwon/go-fundamental-programming/blob/master/lectures/lecture4.md target=_blank rel="noopener noreffer">第四课：常量与运算符</a>。</p><p><code>iota</code> 也可以用在表达式中，如：<code>iota + 50</code>。在每遇到一个新的常量块或单个常量声明时， <code>iota</code> 都会重置为 0（ <strong>简单地讲，每遇到一次 const 关键字，<code>iota</code> 就重置为 0</strong> ）。</p><p>当然，常量之所以为常量就是恒定不变的量，因此我们无法在程序运行过程中修改它的值；如果你在代码中试图修改常量的值则会引发编译错误。</p><h2 id=2-变量>2. 变量</h2><p>声明变量的一般形式是使用 <code>var</code> 关键字：<code>var identifier type</code>。</p><p>需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？</p><p>首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：<code>int* a, b;</code>。在这个例子中，只有 <code>a</code> 是指针而 <code>b</code> 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 <a href=http://blog.golang.org/2010/07/gos-declaration-syntax.html target=_blank rel="noopener noreffer">Go 语言的声明语法</a> 页面找到有关于这个话题的更多讨论）。</p><p>而在 Go 中，则可以很轻松地将它们都声明为指针类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>*</span><span class=kt>int</span>
</code></pre></td></tr></table></div></div><p>其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。</p><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>a</span> <span class=kt>int</span>
<span class=kd>var</span> <span class=nx>b</span> <span class=kt>bool</span>
<span class=kd>var</span> <span class=nx>str</span> <span class=kt>string</span>
</code></pre></td></tr></table></div></div><p>你也可以改写成这种形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
	<span class=nx>a</span> <span class=kt>int</span>
  <span class=nx>b</span> <span class=kt>bool</span>
  <span class=nx>str</span> <span class=kt>string</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>这种<strong>因式分解关键字的写法一般用于声明全局变量</strong>。</p><p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 <code>0</code>，<code>float32(64)</code> 为 <code>0.0</code>，bool 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code>。记住，所有的内存在 Go 中都是经过初始化的。</p><p>变量的命名规则遵循骆驼命名法，即<strong>首个单词小写，每个新单词的首字母大写</strong>，例如：<code>numShips</code> 和 <code>startDate</code>。</p><p>但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（可见性规则）。</p><h4 id=作用域>作用域</h4><p>一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。</p><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。像 <code>if</code> 和 <code>for</code> 这些控制结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。</p><p>尽管变量的标识符必须是唯一的，但你可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏（结束内部代码块的执行后隐藏的外部同名变量又会出现，而内部同名变量则被释放），你任何的操作都只会影响内部代码块的局部变量。</p><h4 id=声明与赋值>声明与赋值</h4><p>变量可以编译期间就被赋值，赋值给变量使用运算符等号 <code>=</code>，当然你也可以在运行时对变量进行赋值操作。</p><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>a</span> <span class=p>=</span> <span class=mi>15</span>
<span class=nx>b</span> <span class=p>=</span> <span class=kc>false</span>
</code></pre></td></tr></table></div></div><p>一般情况下，当变量a和变量b之间类型相同时，才能进行如 <code>a = b</code> 的赋值。</p><p>声明与赋值（初始化）语句也可以组合起来。</p><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>identifier</span> <span class=p>[</span><span class=kd>type</span><span class=p>]</span> <span class=p>=</span> <span class=nx>value</span>
<span class=kd>var</span> <span class=nx>a</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>15</span>
<span class=kd>var</span> <span class=nx>i</span> <span class=p>=</span> <span class=mi>5</span>
<span class=kd>var</span> <span class=nx>b</span> <span class=kt>bool</span> <span class=p>=</span> <span class=kc>false</span>
<span class=kd>var</span> <span class=nx>str</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;Go says hello to the world!&#34;</span>
</code></pre></td></tr></table></div></div><p>但是 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。因此，你还可以使用下面的这些形式来声明及初始化变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=mi>15</span>
<span class=kd>var</span> <span class=nx>b</span> <span class=p>=</span> <span class=kc>false</span>
<span class=kd>var</span> <span class=nx>str</span> <span class=p>=</span> <span class=s>&#34;Go says hello to the world!&#34;</span>
</code></pre></td></tr></table></div></div><p>或：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
	<span class=nx>a</span> <span class=p>=</span> <span class=mi>15</span>
  <span class=nx>b</span> <span class=p>=</span> <span class=kc>false</span>
  <span class=nx>str</span> <span class=p>=</span> <span class=s>&#34;Go says hello to the world!&#34;</span>
  <span class=nx>numShips</span> <span class=p>=</span> <span class=mi>50</span>
  <span class=nx>city</span> <span class=kt>string</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>不过自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>n</span> <span class=kt>int64</span> <span class=p>=</span> <span class=mi>2</span>
</code></pre></td></tr></table></div></div><p>然而，<code>var a</code> 这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据。变量的类型也可以在运行时实现自动推断，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
  <span class=nx>HOME</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;HOME&#34;</span><span class=p>)</span>
  <span class=nx>USER</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;USER&#34;</span><span class=p>)</span>
	<span class=nx>GOROOT</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GOROOT&#34;</span><span class=p>)</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><p>这种写法主要用于声明包级别的全局变量。</p><p>当你在函数体内声明局部变量时，可以使用简短声明语法 <code>:=</code>，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>a</span> <span class=o>:=</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p>下面这个例子展示了如何通过 <code>runtime</code> 包在运行时获取所在的操作系统类型，以及如何通过 <code>os</code> 包中的函数 <code>os.Getenv()</code> 来获取环境变量中的值，并保存到 <code>string</code> 类型的局部变量 <code>path</code> 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;os&#34;</span>
  <span class=s>&#34;runtime&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>goos</span> <span class=kt>string</span> <span class=p>=</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>GOOS</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The operating system is: %s\n&#34;</span><span class=p>,</span> <span class=nx>goos</span><span class=p>)</span>
  <span class=nx>path</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;PATH&#34;</span><span class=p>)</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Path is: %s\n&#34;</span><span class=p>,</span> <span class=nx>path</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果你在 Windows 下运行这段代码，则会输出 <code>The operating system is: windows</code> 以及相应的环境变量的值；如果你在 Linux 下运行这段代码，则会输出 <code>The operating system is: linux</code> 以及相应的的环境变量的值。</p><h4 id=简短赋值>简短赋值</h4><p>我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，而这个时候再在声明语句写上 <code>var</code> 关键字就显得有些多余了，因此我们可以将它们简写为 <code>a := 50</code> 或 <code>b := false</code>。</p><p><code>a</code> 和 <code>b</code> 的类型（<code>int</code> 和 <code>bool</code>）将由编译器自动推断。</p><p>这是使用变量的首选形式，但是<strong>它只能被用在函数体内，而不可以用于全局变量的声明与赋值</strong>。使用操作符 <code>:=</code> 可以高效地创建一个新的变量，称之为初始化声明。</p><p><strong>注意事项</strong></p><p><code>:=</code> 是声明语句。如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：<code>a := 20</code> 就是不被允许的，编译器会提示错误 <code>no new variables on left side of :=</code>，但是 <code>a = 20</code> 是可以的，因为这是给相同的变量赋予一个新的值。</p><p>如果你在定义变量 <code>a</code> 之前使用它，则会得到编译错误 <code>undefined: a</code>。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 <code>a</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;abc&#34;</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello, world&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>尝试编译这段代码将得到错误 <code>a declared and not used</code>。</p><p>此外，单纯地给 <code>a</code> 赋值也是不够的，这个值必须被使用，所以使用 <code>fmt.Println("hello, world", a)</code> 会移除错误。</p><p>但是<strong>全局变量是允许声明却不使用</strong>。</p><p>其他的简短形式为：</p><p>同一类型的多个变量可以声明在同一行，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=kt>int</span>
</code></pre></td></tr></table></div></div><p>多变量可以在同一行进行赋值，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=p>=</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=s>&#34;abc&#34;</span>
</code></pre></td></tr></table></div></div><p>上面这行假设了变量 <code>a</code>，<code>b</code> 和 <code>c</code> 都已经被声明，否则的话应该这样使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=s>&#34;abc&#34;</span>
</code></pre></td></tr></table></div></div><p>右边的这些值以相同的顺序赋值给左边的变量，所以 <code>a</code> 的值是 <code>5</code>， <code>b</code> 的值是 <code>7</code>，<code>c</code> 的值是 <code>"abc"</code>。</p><p>这被称为 <strong>并行</strong> 或 <strong>同时</strong> 赋值。</p><p>如果你想要交换两个变量的值，则可以简单地使用 <code>a, b = b, a</code>。(在 Go 语言中，这样省去了使用交换函数的必要)</p><p>空白标识符 <code>_</code> 也被用于抛弃值，如值 <code>5</code> 在：<code>_, b = 5, 7</code> 中被抛弃。</p><p><code>_</code> 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 <code>val</code> 和错误 <code>err</code> 是通过调用 <code>Func1</code> 函数同时得到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>Func1</span><span class=p>(</span><span class=nx>var1</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><h2 id=3-值类型和引用类型>3. 值类型和引用类型</h2><p>所有像 <code>int</code>、<code>float</code>、<code>bool</code> 和 <code>string</code> 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p><p>另外，像数组和结构体这些复合类型也是值类型。</p><p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 <code>i</code> 的值进行了拷贝：</p><p>可以通过 <code>&i</code> 来获取变量 <code>i</code> 的内存地址，例如：<code>0xf840000040</code>（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p><p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p><p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p><p>一个引用类型的变量 <code>r1</code> 存储的是 <code>r1</code> 的值所在的内存地址，或内存地址中第一个字所在的位置。</p><p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p><p>当使用赋值语句 <code>r2 = r1</code> 时，只有引用（地址）被复制。</p><p>如果 <code>r1</code> 的值被改变了，那么这个值的所有引用都会指向被修改后的内容。</p><p>在 Go 语言中，指针属于引用类型，其它的引用类型还包括 slices，maps 和 channel。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。</p><h2 id=4-init函数>4. init函数</h2><p>变量除了可以在全局声明中初始化，也可以在 <code>init()</code> 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 <code>main()</code> 函数高。</p><p>每个源文件可以包含多个 <code>init()</code> 函数，同一个源文件中的 <code>init()</code> 函数会按照从上到下的顺序执行，如果一个包有多个源文件包含 <code>init()</code> 函数的话，则官方鼓励但不保证以文件名的顺序调用。初始化总是以单线程并且按照包的依赖关系顺序执行。</p><p>一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// init.go
</span><span class=c1></span><span class=kn>package</span> <span class=nx>trans</span>

<span class=kn>import</span> <span class=s>&#34;math&#34;</span>

<span class=kd>var</span> <span class=nx>Pi</span> <span class=kt>float64</span>

<span class=kd>func</span> <span class=nf>init</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>Pi</span> <span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=nx>math</span><span class=p>.</span><span class=nf>Atan</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>	<span class=c1>//init() function computes Pi
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在它的 <code>init()</code> 函数中计算变量 <code>Pi</code> 的初始值。</p><p>下面的代码导入上文所创建包 <code>trans</code>（需要 <code>init.go</code> 目录为 <code>./trans/init.go</code> ）并且使用到了变量 <code>Pi</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;./trans&#34;</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=nx>twoPi</span> <span class=p>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>trans</span><span class=p>.</span><span class=nx>Pi</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;2*Pi = %g\n&#34;</span><span class=p>,</span> <span class=nx>twoPi</span><span class=p>)</span>	<span class=c1>// 2*Pi = 6.283185307179586
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p><code>init()</code> 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 <code>backend()</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>init</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// setup preparations
</span><span class=c1></span>  <span class=k>go</span> <span class=nf>backend</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-02-05</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ data-title=Golang语法基础3-常量、变量与基本数据类型><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/>Golang语法基础</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/ class=prev rel=prev title=Golang语法基础2-基本结构和语法><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Golang语法基础2-基本结构和语法</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.63.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i>LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Ge Yunfei</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>