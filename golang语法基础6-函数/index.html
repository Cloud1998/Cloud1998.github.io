<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Golang语法基础6-函数 - Cloud1998's blog</title><meta name=Description content="这是我的全新 Hugo 网站"><meta property="og:title" content="Golang语法基础6-函数"><meta property="og:description" content="本文介绍 Golang 中的函数。"><meta property="og:type" content="article"><meta property="og:url" content="http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"><meta property="og:image" content="http://Cloud1998.github.io/logo.png"><meta property="article:published_time" content="2023-02-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-12T00:00:00+00:00"><meta property="og:site_name" content="我的网站"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://Cloud1998.github.io/logo.png"><meta name=twitter:title content="Golang语法基础6-函数"><meta name=twitter:description content="本文介绍 Golang 中的函数。"><meta name=application-name content="我的网站"><meta name=apple-mobile-web-app-title content="我的网站"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/><link rel=prev href=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/><link rel=next href=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础6-函数","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/Cloud1998.github.io\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0\/"},"genre":"posts","keywords":"Golang语法基础","wordcount":4793,"url":"http:\/\/Cloud1998.github.io\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0\/","datePublished":"2023-02-12T00:00:00+00:00","dateModified":"2023-02-12T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Ge Yunfei"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Cloud1998's blog">Cloud1998's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Cloud1998's blog">Cloud1998's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Golang语法基础6-函数</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Ge Yunfei</a></span>&nbsp;<span class=post-category>included in <a href=/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw" aria-hidden=true></i>编程技术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-02-12>2023-02-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4793 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;10 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#31-参数传递类型>3.1 参数传递类型</a></li><li><a href=#32-命名参数>3.2 命名参数</a></li><li><a href=#33-空白符>3.3 空白符</a></li><li><a href=#34-变长参数>3.4 变长参数</a></li><li><a href=#35-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-匿名函数与闭包>5. 匿名函数与闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></nav></div></div><div class=content id=content><p>本文介绍 Golang 中的函数。</p><h2 id=1-函数声明与定义>1. 函数声明与定义</h2><p>Go 中有三种类型的函数：</p><ol><li>普通的带有名字的函数</li><li>匿名函数</li><li>方法（Methods，在结构体部分介绍）</li></ol><p>普通函数声明的基本格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>定义就需要添加大括号和函数体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>{</span>
    <span class=o>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。</p><p>当函数执行到代码块最后一行，也就是最后一个 <code>}</code> 之前，或者执行到 <code>return</code> 语句的时候就会退出。</p><p>main 函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有 <code>init()</code> 函数会先执行该函数。</p><p>main 函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main 函数一旦返回就表示程序已成功执行并立即退出。同样，<code>init()</code> 函数也没有返回值。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>Tips<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>函数参数、返回值以及它们的类型被统称为<strong>函数签名</strong>。</div></div></div><h2 id=2-函数调用>2. 函数调用</h2><p>同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>pack1</span><span class=p>.</span><span class=nf>FunctionName</span><span class=p>(</span><span class=nx>arg1</span><span class=p>,</span> <span class=nx>arg2</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=nx>argn</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><code>pack1</code> 是包名，<code>FunctionName</code> 是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main before calling greeting&#34;</span><span class=p>)</span>
    <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main after calling greeting&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In greeting: Hi!!!!!&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// In main before calling greeting
</span><span class=c1></span><span class=c1>// In greeting: Hi!!!!!
</span><span class=c1></span><span class=c1>// In main after calling greeting
</span></code></pre></td></tr></table></div></div><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>Tips<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>函数一般是在其他函数里面被调用的，这个其他函数被称为<strong>调用函数</strong> (calling function)。理论上，函数调用其他函数的次数是无穷的（直到函数调用栈被耗尽）。</div></div></div><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fw" aria-hidden=true></i>注意<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><strong>函数重载</strong> (function overloading) 指的是可以编写多个同名函数，只要它们拥有不同的形参/或者不同的返回值，在 Go 里面函数重载是不被允许的。这将导致编译错误。</div></div></div><h2 id=3-函数参数与返回值>3. 函数参数与返回值</h2><p>除了 <code>mian()</code> 和 <code>init()</code> 函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以 <code>return</code> 或 <code>panic</code> 语句结尾，<code>return</code> 可以返回多个值，多值返回是 Go 的一大特性。</p><h3 id=31-参数传递类型>3.1 参数传递类型</h3><p>Go 中的参数传递类型有两种：按值传递和按引用传递。</p><p>Go 默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符 <code>&</code>，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。</p><p>函数调用时，切片（slice）、映射（map）、接口（interface）、通道（channel）这些<strong>引用类型默认使用按引用传递</strong>。几乎在任何情况下，按引用传递的消耗都比按值传递小。按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用 <code>return</code> 返回。</p><h3 id=32-命名参数>3.2 命名参数</h3><p>函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如 <code>func f(int, int, float64)</code>，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>var</span> <span class=nx>num</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
<span class=kd>var</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=kt>int</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num = %d, 2x num = %d, 3x num = %d\n&#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>,</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>x2</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>x3</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>x2</span> <span class=p>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=nx>x3</span> <span class=p>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=c1>// return x2, x3
</span><span class=c1></span>    <span class=k>return</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// num = 10, 2x num = 20, 3x num = 30    
</span><span class=c1></span><span class=c1>// num = 10, 2x num = 20, 3x num = 30 
</span></code></pre></td></tr></table></div></div><p>命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的 return 语句（带参数也不会出错）。</p><p>当需要返回多个非命名返回值时，需要使用括号包围，如<code>(int, int)</code>，但对命名返回值，即使只有一个返回值，也要用括号包围。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>Tips<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><strong>尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。</strong></div></div></div><h3 id=33-空白符>3.3 空白符</h3><p>空白符<code>_</code>用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。</p><h3 id=34-变长参数>3.4 变长参数</h3><p>如果函数最后一个参数是<code>...type</code>的形式，那么函数就可以处理一个变长的参数，这个长度可以是 0，这样的函数称为变参函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>myFunc</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>arg</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>变长参数的本质是一个切片，如下例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Greeting</span><span class=p>(</span><span class=nx>prefix</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>who</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span>	<span class=c1>// 函数定义
</span><span class=c1></span><span class=nf>Greeting</span><span class=p>(</span><span class=s>&#34;hello:&#34;</span><span class=p>,</span> <span class=s>&#34;Joe&#34;</span><span class=p>,</span> <span class=s>&#34;Anna&#34;</span><span class=p>,</span> <span class=s>&#34;Eileen&#34;</span><span class=p>)</span>	<span class=c1>// 调用
</span></code></pre></td></tr></table></div></div><p>变量<code>who</code>的值为 <code>[]string{"Joe", "Anna", "Eileen"}</code>。</p><p>如果参数本身就存在一个切片类型中，比如切片 <code>slice1</code>，则可以通过 <code>slice1...</code> 的形式传递参数，之前的切片部分使用 append 函数时已经这样使用过。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>x</span> <span class=o>:=</span> <span class=nf>min</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum is: %d\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
	<span class=nx>slice</span> <span class=o>:=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>7</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>1</span><span class=p>}</span>
	<span class=nx>x</span> <span class=p>=</span> <span class=nf>min</span><span class=p>(</span><span class=nx>slice</span><span class=o>...</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum in the slice is: %d&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>min</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span>
	<span class=p>}</span>
	<span class=nx>min</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>v</span> <span class=p>&lt;</span> <span class=nx>min</span> <span class=p>{</span>
			<span class=nx>min</span> <span class=p>=</span> <span class=nx>v</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>min</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// The minimum is: 0
</span><span class=c1></span><span class=c1>// The minimum in the slice is: 1
</span></code></pre></td></tr></table></div></div><p>一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>F1</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>F2</span><span class=p>(</span><span class=nx>s</span><span class=o>...</span><span class=p>)</span>
	<span class=nf>F3</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>F2</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
<span class=kd>func</span> <span class=nf>F3</span><span class=p>(</span><span class=nx>s</span> <span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>变长参数可以作为对应类型的 slice 进行二次传递。</p><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fw" aria-hidden=true></i>注意<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>但是如果变长参数的类型并不是都相同的呢？有 2 种方案可以解决这个问题；</p><ol><li>使用结构体</li><li>使用空接口</li></ol></div></div></div><h3 id=35-函数作为参数>3.5 函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要这个被调用函数的返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>callback</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nx>Add</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The sum of %d and %d is: %d\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=o>+</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>callback</span><span class=p>(</span><span class=nx>y</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>f</span><span class=p>(</span><span class=nx>y</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// this becomes Add(1, 2)
</span><span class=c1></span><span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// The sum of 1 and 2 is: 3
</span></code></pre></td></tr></table></div></div><h2 id=4-内置函数>4. 内置函数</h2><p>Go 语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如 <code>len()</code>, <code>cap()</code>, <code>append()</code>，以下是内置函数列表：</p><table><thead><tr><th align=center>名称</th><th align=center>说明</th></tr></thead><tbody><tr><td align=center><code>close()</code></td><td align=center>用于管道通信。</td></tr><tr><td align=center><code>len()</code>、<code>cap()</code></td><td align=center><code>len()</code> 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；<code>cap()</code> 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map()</code>）。</td></tr><tr><td align=center><code>new()</code>、<code>make()</code></td><td align=center><code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make()</code> 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。<code>make(T)</code> 返回类型 T 的初始化之后的值，因此它比 <code>new()</code> 进行更多的工作。</td></tr><tr><td align=center><code>copy()</code>、<code>append()</code></td><td align=center>用于复制和连接切片。</td></tr><tr><td align=center><code>panic()</code>、<code>recover()</code></td><td align=center>两者均用于错误处理机制。</td></tr><tr><td align=center><code>print()</code>、<code>println()</code></td><td align=center>底层打印函数，在部署环境中建议使用 fmt 包。</td></tr><tr><td align=center><code>complex()</code>、<code>real()</code>、 <code>imag()</code></td><td align=center>用于创建和操作复数。</td></tr></tbody></table><h2 id=5-匿名函数与闭包>5. 匿名函数与闭包</h2><p>匿名函数是类似 <code>func(x, y int) int { return x + y }</code> 这样没有名字的函数。这样的函数不能够独立存在（编译器会返回错误：<code>non-declaration statement outside function body</code>），但可以被赋值于某个变量，即保存函数的地址到变量中：<code>fplus := func(x, y int) int { return x + y }</code>，然后通过变量名对函数进行调用：<code>fplus(3,4)</code>。当然，匿名函数也可以被直接调用，例如：<code>func(x, y int) int { return x + y } (3, 4)</code>。</p><p>下面是一个计算从 1 到 1 百万整数的总和的匿名函数。<strong>表示参数列表的第一对括号必须紧挨着关键字 <code>func</code></strong>，因为匿名函数没有名称。花括号 <code>{}</code> 涵盖着函数体，<strong>最后的一对括号表示对该匿名函数的调用</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mf>1e6</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>sum</span> <span class=o>+=</span> <span class=nx>i</span>
	<span class=p>}</span>
<span class=p>}</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span><span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
	<span class=err>…</span>
<span class=p>}</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>还应该知道的，匿名函数可以被赋值给某个变量，如<code>fplus := func(x, y int) int { return x + y }</code>，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：<code>fplus(3, 4)</code>。</p><p>所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
        <span class=nx>i</span><span class=o>++</span>
        <span class=k>return</span> <span class=nx>i</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 <code>i</code>，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>f</span> <span class=p>=</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>x</span> <span class=kt>int</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>delta</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
		<span class=nx>x</span> <span class=o>+=</span> <span class=nx>delta</span>
		<span class=k>return</span> <span class=nx>x</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// 1 - 21 - 321
</span></code></pre></td></tr></table></div></div><p>从这里例子中我们注意到 <code>x</code> 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为<strong>函数被赋值给 <code>f</code> 之后，其实将整个闭包包括环境都赋值给了 <code>f</code>，变量 <code>f</code> 的生存周期内，其值是不变的，所以结果才会累积</strong>。</p><p>在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>g</span> <span class=kt>int</span>
<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>s</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>i</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span> <span class=nx>s</span> <span class=o>+=</span> <span class=nx>j</span> <span class=p>}</span>
	<span class=nx>g</span> <span class=p>=</span> <span class=nx>s</span>
<span class=p>}</span><span class=p>(</span><span class=mi>1000</span><span class=p>)</span> <span class=c1>// Passes argument 1000 to the function literal.
</span></code></pre></td></tr></table></div></div><p>这样闭包函数就能够被应用到整个集合的元素上，并修改它们的值。然后这些变量就可以用于表示或计算全局或平均值。</p><p>这种返回值为另一个函数的函数的形式也被称之为<strong>工厂函数</strong>，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=nx>suffix</span> <span class=kt>string</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
		<span class=k>if</span> <span class=p>!</span><span class=nx>strings</span><span class=p>.</span><span class=nf>HasSuffix</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>suffix</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>name</span> <span class=o>+</span> <span class=nx>suffix</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nx>name</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>现在可以生成如下函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>addBmp</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.bmp&#34;</span><span class=p>)</span>
<span class=nx>addJpeg</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.jpeg&#34;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>然后调用它们：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>addBmp</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.bmp
</span><span class=c1></span><span class=nf>addJpeg</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.jpeg
</span></code></pre></td></tr></table></div></div><h2 id=6-defer和追踪>6. defer和追踪</h2><p>关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种：</p><ol><li>包含 defer 语句的函数返回前</li><li>包含 defer 语句的函数执行到末尾</li><li>所在的 goroutine 发生 panic 时</li></ol><p>一个例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Fourth&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;First&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Third&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// First
</span><span class=c1></span><span class=c1>// Third
</span><span class=c1></span><span class=c1>// Fourth
</span></code></pre></td></tr></table></div></div><p>defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>
<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Deferred print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=nx>i</span><span class=o>++</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Normal print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// Normal print: 2
</span><span class=c1></span><span class=c1>// Deferred print: 1
</span></code></pre></td></tr></table></div></div><p>不要小看这一点，如果 defer 语句中嵌套了其他的函数，将会出现意料之外的结果，看看下面代码追踪的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=c1>// 用于在进入某个函数时打印相关的消息
</span><span class=c1></span><span class=kd>func</span> <span class=nf>trace</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;entering:&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
	<span class=k>return</span> <span class=nx>s</span>
<span class=p>}</span>

<span class=c1>// 用于在离开某个函数时打印相关的消息
</span><span class=c1></span><span class=kd>func</span> <span class=nf>un</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;leaving:&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>a</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>defer</span> <span class=nf>un</span><span class=p>(</span><span class=nf>trace</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;in a&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>b</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// 由于 defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，因此它会先执行 trace(&#34;b&#34;) 来确定函数 un() 中参数的值
</span><span class=c1></span>	<span class=k>defer</span> <span class=nf>un</span><span class=p>(</span><span class=nf>trace</span><span class=p>(</span><span class=s>&#34;b&#34;</span><span class=p>)</span><span class=p>)</span> 
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;in b&#34;</span><span class=p>)</span>
	<span class=nf>a</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>b</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// entering: b
</span><span class=c1></span><span class=c1>// in b
</span><span class=c1></span><span class=c1>// entering: a
</span><span class=c1></span><span class=c1>// in a
</span><span class=c1></span><span class=c1>// leaving: a
</span><span class=c1></span><span class=c1>// leaving: b
</span></code></pre></td></tr></table></div></div><p>但与匿名函数结合起来后，变量的值在函数运行时才会确定：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>1</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>2</span>
    <span class=k>return</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nf>f1</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// 3
</span></code></pre></td></tr></table></div></div><p>上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事</p><ol><li>defer 函数执行时机是外层函数设置返回值之后，即将返回之前</li><li>return xxx 操作并不是原子的</li></ol><p>下面的例子中， <code>return 0</code> 实际上可以拆分为 <code>r = 0; return</code> 两条语句，因此输出是 1 不是 0：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=mi>0</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>f1</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>来一个更复杂的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>x</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>triple</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// 9
</span></code></pre></td></tr></table></div></div><p>上面的例子实际上等价于：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
    <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>多个 defer 也可以同时使用时，以逆序执行，即后进先出（类似栈）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=c1>// 4 3 2 1 0
</span></code></pre></td></tr></table></div></div><p>defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如</p><ol><li><p>关闭文件流</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// open a file
</span><span class=c1></span><span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>解锁一个加锁的资源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>打印最终报告</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>printHeader</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nf>printFooter</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>关闭数据库链接</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// open a database connection
</span><span class=c1></span><span class=k>defer</span> <span class=nf>disconnectFromDB</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li></ol><h2 id=7-编写规范>7. 编写规范</h2><p>Go 是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是 Uber 开源在 github 的编码规范，有两条主要规则</p><ol><li><p>函数应按粗略的调用顺序排序</p></li><li><p>同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于<code>newXYZ()</code>这样的新建某个类型的函数。一个简单的例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>something</span> <span class=kd>struct</span><span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
      
<span class=kd>func</span> <span class=nf>newSomething</span><span class=p>(</span><span class=p>)</span> <span class=o>*</span><span class=nx>something</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>something</span><span class=p>{</span><span class=p>}</span>
<span class=p>}</span>
      
<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>something</span><span class=p>)</span> <span class=nf>Cost</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>weights</span><span class=p>)</span>
<span class=p>}</span>
      
<span class=kd>func</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>n</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span><span class=o>...</span><span class=p>}</span>
   
<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span><span class=p>{</span>
  <span class=o>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ol><p>最后，main 函数放在所有函数的最后。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-02-12</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=http://Cloud1998.github.io/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/ data-title=Golang语法基础6-函数><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/>Golang语法基础</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/ class=prev rel=prev title=Golang语法基础5-数组、切片与映射><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Golang语法基础5-数组、切片与映射</a>
<a href=/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/ class=next rel=next title=Golang语法基础7-结构体与方法>Golang语法基础7-结构体与方法<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.63.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i>LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Ge Yunfei</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>