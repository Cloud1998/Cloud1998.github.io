[{"categories":["编程技术"],"content":"计算机系统漫游 如何避免由计算机表示数字的方式引起的奇怪的数字错误。 怎样通过一些小窍门来优化自己的C代码，以及充分利用现代处理器和存储器系统的设计 编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞 如何识别和避免链接时那些错误 如何编写自己的Unix shell，以及自己的动态存储分配包，和自己的Web服务器 认识并发带来的希望与陷阱 本书将跟踪 helloworld 程序的生命周期来开始对系统的学习，从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。 我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:0:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"信息就是位+上下文 源程序（源文件）即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和值 1 组成的位序列（又称比特序列）。 8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。 大部分现代计算机系统都是用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的、单字节大小的整数值来表示每个字符。例如整数值 97 用于表示小写字母 a。 hello.c 程序是以字节序列的方式存储在文件中，每个字节都有一个整数值，对应于某些字符。 像 hello.c 这样只由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件。 系统中的所有信息，包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文（环境）。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:1:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"程序被其他程序翻译成不同格式 为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。 目标程序也称为可执行目标文件。 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的： gcc -o hello hello.c 在上面的命令中，GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成： 执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统(compilation system)。 预处理阶段 预处理器(cpp)根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的 # include \u003cstdio.h\u003e命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通长以 .i 作为文件名扩展。 编译阶段 编译器(ccl)将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数 main 的定义，如下所示： mian: subq $8, %rsp movl $.LCO, %edi call puts movl $0, %eax addq %8, %rsp ret 从第 2 行开始往下的每条语句都以一种文本格式描述了一条低级机器语言指令。 汇编阶段 汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o 文件，将看到一堆乱码。 链接阶段 hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器(ld)就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:2:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"了解编译系统如何工作是大有益处的 对于简单的程序，我们可以依靠编译系统生成正确有效的机器代码，但是在面对复杂程序时，了解编译系统是如何工作会给我们带来帮助，主要体现在： 优化程序性能 一个 switch 语句是否总是比一系列的 if-else 语句高效得多？ 一个函数调用的开销有多大？ while 循环比 for 循环更有效吗？ 指针引用比数组索引更有效吗？ 为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？ 为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？ 理解链接时出现的错误 链接器报告说它无法解析一个引用，这是什么意思？ 静态变量和全局变量的区别是什么？ 如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？ 静态库和动态库的区别是什么？ 我们在命令行上排列库的顺序有什么影响？ 为什么有些链接错误直到运行时才会出现？ 避免安全漏洞 缓冲区溢出错误 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:3:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"处理器读并解释储存在内存中的指令 此刻，源程序已经被编译系统翻译成了可执行目标文件 hello，并被存放在磁盘上，若想要在 Unix 系统中运行该可执行文件，则需要将它的文件名输入到名为 shell 的应用程序中： linux\u003e ./hello hello, world linux\u003e 在 Unix 系统中，shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell 将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:4:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"系统硬件的组成 为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件知识。一个系统硬件包含以下几部分： 总线 总线负责在各个部件间传递信息。它通常被设计成传送定长的字节块，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32位），要么是 8 个字节（64位）。 I/O设备 I/O（输入/输出）设备是系统与外部世界的联系通道。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器和适配器之间的区别主要在它们的封装方式。 控制器是 I/O 设备本身或者系统的主印制电路板（主板）上的芯片组。 适配器是一块插在主板插槽上的卡。 它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。 主存 主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。 从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。 从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。 处理器 中央处理单元（CPU）简称处理器，负责解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。从系统通电开始，直到系统断电，处理器一直在不断地执行 PC 指向的指令，再更新 PC，使其指向下一条指令。 处理器看上去是它的指令集架构的简单实现。但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，本书将处理器的指令集架构和处理器的微体系结构区分开来。 指令集架构描述的是每条机器代码指令的效果。 微体系结构描述的是处理器实际上是如何实现的。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:4:1","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"运行 hello 程序 当我们在键盘上输入字符串 ./hello 后，shell 程序将字符逐一读入寄存器，然后再把它们放到内存中去。 当我们敲下回车键，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存（数据包括最终会被输出的字符串hello, world\\n。 一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 hello, world\\n 字符串中的字节从主存复制到寄存器，再从寄存器复制到显示设备，最终显示在屏幕上。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:4:2","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"高速缓存至关重要 这个简单的例子揭示了一个重要的问题，即系统花费了大量的时间，把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。类似地，字符串 hello, world\\n 开始时在磁盘上，然后被复制到主存，又被复制到寄存器，最后从寄存器复制到显示设备。 对于程序员来说，这些复制就是开销，减慢了程序真正的工作。因此，系统设计者的一个目标就是使这些复制操作尽可能快地完成。 根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。 例如，寄存器只能存储几百字节的信息，而主存里可存放几十亿字节，但处理器从寄存器中读取数据比从主存中读取数据要快 100 倍。 近些年随着半导体技术的进步，这种差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache memory，简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。 Cache 也会分级，位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器一样快。L2 高速缓存的容量为数十万到数百万字节，它通过一条特殊的总线连接到处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访问主存的时间快 5~10 倍。 Cache 是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。因为有了 Cache，系统可以获得一个很大的存储器，同时访问速度也很快，它利用了高速缓存的局部性原理，通过让 Cache 里存放可能经常访问的数据，大部分的内存操作都能在快速的 Cache 中完成。 局部性原理：即程序具有访问局部区域里的数据和代码的趋势。 意识到 Cache 的存在，让程序员能够利用 Cache 将程序的性能提高一个数量级。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:5:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"操作系统管理硬件 当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell 和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。所有应用程序对硬件的操作尝试都必须通过操作系统。 操作系统有两个基本的功能： 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂、不同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:6:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"进程 像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。这种假象是通过进程这个概念来实现的。 进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。 传统 CPU 在一个时刻只能执行一个程序，而多核 CPU 能同时执行多个程序。无论是在单核还是多核系统中，CPU 看上去都像是在并发地执行多个进程，这是通过 CPU 在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文。它包括许多信息，比如 PC 和 寄存器的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始。 从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻内存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核，然后内核执行被请求的操作，并返回应用程序。 注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:6:1","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"线程 在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:6:2","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"虚拟内存 虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。 每个进程看到的虚拟地址空间由大量准确定义的区域构成，每个区域都有专门的功能。了解每一个区域是非常有益的，它们分别是： 程序代码和数据 对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。 堆 代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。 共享库 大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。 栈 位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。 内核虚拟内存 地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:6:3","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"文件 文件就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:6:4","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"重要主题 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:7:0","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"Amdahl 定律 该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为 $T_{old}$，假设系统某部分所需执行时间与该时间的比例为 $a$，而该部分性能提升比例为 $k$。即该部分初始所需时间为 $aT_{old}$，现在所需时间为$(aT_{old})/k$。因此，总的执行时间应为： $$T_{new}=(1-a)T_{old}+(aT_{old})/k=T_{old}[(1-a)+a/k]$$ 由此，可计算加速比$S=T_{old}/T_{new}$为： $$S=\\dfrac{1}{(1-a)+a/k}$$ 它告诉我们，要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 Amdahl 定律一个有趣的特殊情况是考虑 $k$ 趋向于 $\\infin$ 时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。于是我们得到： $$S_\\infin=\\dfrac{1}{1-a}$$ Amdahl 定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低成本，或学生想要提高自己绩点平均值等方面。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:7:1","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"并发和并行 并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统。并行（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。 线程级并发 构建在进程这个抽象概念之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自 1960 年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为单处理器系统。从 1980 年代开始，在大规模的计算中，开始出现了多处理器系统的身影，它是一个单操作系统内核控制的多处理器组成的系统。 多核处理器是将多个 CPU（称为【核】）集成到一个集成电路芯片上。典型的多核 CPU，每个核都有自己的 L1 和 L2 高速缓存，L1 高速缓存又可以分成两个部分，一个保存最近读取到的指令，另一个存放数据。酷睿 i7 可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。 多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，在执行单个大型应用程序时，他可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。 指令级并行 现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，需要多个（3~10 个）时钟周期来执行一条指令。最近的处理器可以保存每个时钟周期执行 2~4 条指令。其实每条指令从开始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。其中一个概念叫做流水线（pipelining），在流水线中，执行一条指令所需要的活动被划分成了不同的步骤，以此并行地执行多条指令，使处理器能够达到接近于一个时钟周期一条指令的执行速率。 如果处理器可以达到比一个周期一条指令更快的执行速率，就称为超标量（super-scalar）处理器。大多数现代处理器都支持超标量操作。理解超标量处理器的高级模型，可以帮助我们理解程序的性能，然后，我们就可以写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。 单指令、多数据并行 在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。 ","date":"2023-05-18","objectID":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/:7:2","tags":["读书笔记"],"title":"CSAPP读书笔记01-计算机系统漫游","uri":"/csapp01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"categories":["编程技术"],"content":"本系列将学习卡内基梅隆大学的公开课15-213系列，主讲人是Randal E. Bryant和David R. O’Hallaron，教材是CSAPP，视频资料于2015年秋录制。 这门课的目的是让你深入了解当在执行你的代码时，计算机都做了哪些工作，你会明白程序是如何运行的以及机器是如何支持程序运行的、为什么有时候程序可以正常运行有时候却不能。 同时这门课也是其他课程的先导课，你会从这门课上学习到一些概念，然后能够学习更局限但更深层次的课程。 ","date":"2023-04-17","objectID":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/:0:0","tags":["公开课"],"title":"CMU15-213学习笔记01-绪论","uri":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/"},{"categories":["编程技术"],"content":"Ints 不是整数，Floats 不是实数 第一个例子是：$X^2 \\ge 0$？ 初中时，我们都曾经学过，如果你计算一个数的平方，只要它不是虚数，那么结果至少是0。所以对于一个整数或实数，它的平方我们会认为结果是一个非负数。 大多数情况下对于 float 类型所表示的浮点数会得到正确的结果， 但是对于 int 型就不一定了，例如： $40000 * 40000 = 1600000000$ $50000 * 50000 = ?$ 当我们在计算 40000 的平方时，会得到正确的结果，但是当在计算 50000 * 50000 时，你会得到一个很奇怪的数字，它看起来和你所期待的50000平方的结果大相径庭，它是一个负数。看起来程序好像出错了，但是实际上并不是，因为这台计算机期望数字是32-bit（32位）的值。 这个例子说明你对整数运算的正常期望可能成立，也可能不成立。 第二个例子是：$(x+y)+z=x+(y+z)$？ 对于无符号整数和有符号整数，尽管它们会产生溢出，但是它们会遵守交换律和结合律，所以这是正确的。 但是对于浮点数而言，这就是错误的，例如： $(1e20+ -1e20)+3.14 = 3.14$ $1e20+(-1e20+3.14) = 0$ 很明显第二个等式是错误的，产生这个错误的原因是：对于$-1e20$而言，$3.14$实在显得微不足道，所以出于对精度的考虑，就将其忽略了。 这两个例子都说明，计算机在用有限的位组合形式表示在数域中无限的数。 ","date":"2023-04-17","objectID":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/:1:0","tags":["公开课"],"title":"CMU15-213学习笔记01-绪论","uri":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/"},{"categories":["编程技术"],"content":"你必须对汇编有所了解 你很有可能永远不会用汇编语言编写程序，因为编译器比你更好也更有耐心。但是，理解汇编是机器级执行模型的关键。以往的汇编语言的教学通常是教你如何使用各种各样的指令编写程序，而本课程更多是关于如何获取编译器生成的汇编代码，阅读并理解它，这是一种与你能够自己写汇编所不同的能力。 ","date":"2023-04-17","objectID":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/:2:0","tags":["公开课"],"title":"CMU15-213学习笔记01-绪论","uri":"/cmu15-213%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%BB%AA%E8%AE%BA/"},{"categories":["自我提升"],"content":"这一篇主要来构建健身体系的框架，后续的工作即完善和填充这个框架的细节。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"1. 对健康的追求 开始健身的目的很单纯，就是为了增肌、减肥，最好拥有良好的肌肉形态，但逐渐的，促使健身的因素变得复杂，包括 为了增强体质，预防各种疾病，终极的追求是直到死亡前的最后一刻都没有大病缠身； 为了达到一定的体能水平，以便进行任何喜欢的运动或应对可能的户外风险； 为了释放压力。 直到最后，追求健康成为了健身的终极目的。但追求健康并不意味着更简单，因为现代意义的健康包括身体、情感、社交、智力、精神和工作能力等各方面，具体描述如下 身体：有足够精力完成日常活动的能力； 情感：理解感情、接受限制、稳定情绪的能力； 社会：处理家庭和社会关系的能力； 智力：为自我发展而学习和运用知识的能力； 精神：能够找到人生的意义和现实生活的方向； 工作能力：在工作中获得自我肯定和自我价值感的能力。 为追求健康所采取的行动也不再限于健身，还包括了健康饮食、睡眠和压力管理。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"2. 运动、体力活动和健身 运动代指由骨骼肌收缩引起的，能使机体能量消耗增加的一切身体运动。从运动与饮食两个对立面看，运动的主要目的就是消耗能量，而我们的能量消耗主要来源于三个方面 维持生命体征的基础代谢，约占总能量消耗的 60-70% 食物特殊动力学作用（即通常说的食物消化），约占总能量消耗的 10% 各种类型的体力活动，约占总能量消耗的 20-30% 「体力活动」指那些需要付出努力、能量消耗高于安静时水平的体力活动，比如轻型园艺、家务劳动、上班走楼梯等日常活动，它是三种能力消耗来源中最可控的一个，因此也是我们用来保持健康或减肥的主要手段。日常生活中的体力活动主要分四方面： 职业性活动：与工作相关的体力活动； 家务性活动：家庭中的体力活动（如家务、照看小孩、园艺等）； 交通性活动：交通中的体力活动（如步行、骑自行车等）； 休闲性活动：闲暇时间的体力活动，可以进一步分为竞技运动、娱乐性运动和体育锻炼等。 从增加能量消耗的角度看，不少手段都是在这四个方面寻求办法，比如站立办公就是在增加职业性活动所消耗的能量，步行或骑车上班就是在增加交通性活动所消耗的能量等。而我们所提到的健身，主要指人们为增进身体健康，按照结构化流程进行的一种专门的、有计划的体力活动，以提高自身有氧能力为目标的有氧运动、以提高肌力和肌耐力为目标的力量训练都属于其范畴。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"3. 体能 为了囊括所有需要讨论的东西，我们从体能（体适能） 这个概念入手来建立整个框架。 体能代表了身体和精神的能力，不仅表现在运动能力和工作能力上，也表现在对疾病的抵抗力和对环境的适应能力，通常包括与健康相关的健康体能和与运动技能有关的运动体能两部分，它们各自包含的内容如下。 体能 健康体能 运动体能 成分 心肺耐力 肌肉力量与肌肉耐力 柔韧性| 身体成分 速度 爆发力 灵敏性 平衡性 协调性 反应时间 目的 保持身体健康，提高生活质量 提高运动技能水平，增大比赛中获胜的几率 科学研究表明1，运动和健康饮食确实可以避免肥胖和预防各种慢性病，包括心血管病、冠心病、II型糖尿病、部分癌症、部分精神疾病、心肌梗死、痴呆、中风、骨质疏松等。其中，心肺耐力的锻炼可以促进心腔扩大、心壁增厚以及提高心脏最大射血能力，还可以保持血管弹性、维持动脉血压的稳定、增大冠状动脉直径、改善心肌的血液循环。肌肉力量和肌肉耐力的练习则对骨骼系统有重要功效，可以防止骨质疏松，增加关节稳定性，提高动作平衡能力，对由于摔倒、骨折、功能衰退所造成的不良结果起预防作用，也可以使神经肌肉系统、骨骼、关节和韧带承受更大负荷，降低损伤概率。因此，我们主要从健康体能的四个方面进行介绍。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"3.1 心肺耐力 心肺耐力指由心脏、血液、血管和肺组成的呼吸和血液循环系统向肌肉输送氧气和能量物质，维持长时间身体活动需要的能力。 良好的心肺耐力可以使我们轻松应对日常学习和工作，不易感觉疲劳，同时对预防心血管和呼吸系统疾病有重要作用。因为经过长时间的运动刺激，一方面，左心室内腔扩大，心肌有氧代谢能力改善，增强心脏的泵血能力，提高循环系统运输氧气和养分的效率；另一方面，肺通气量的藏家和弥散能力的提高又能促进肺功能的改善，使机体对抗负荷时能得到充足的氧气供应。 训练心肺耐力的主要方式是有氧运动，有氧的含义是运动过程中机体摄入的氧气量和所消耗的氧气量基本相等，处于「有氧」状态，这种状态下，略感气喘，又不至于上气不接下气；稍微出汗，又不至于大汗淋漓；感到全身舒展，但不觉得肢体疲劳。因此，有氧运动主要指以有氧代谢为主的、有节律的、全身主要肌群参与的、经常进行的耐力运动，如步行、慢跑、有氧操、游泳、越野滑雪、跳绳、骑自行车、登山等，另外，某些球类活动（乒乓球、羽毛球、足球、篮球等）、我国传统的体育活动（太极拳、太极剑等）和小负荷的力量训练也都有提高心肺功能的作用。有氧运动具有如下特性 长时间的运动，至少持续 20-60min 全身性的大肌肉活动，不得少于 1/6 有稳定性，应当维持在某一特定强度 有节奏性，是有律动的肢体活动 评价心肺耐力最简单的方法是台阶测试，而通用的评价指标是运动强度。以最大摄氧量百分比计算，运动强度应该在 50%~85%，以更简便实用的心率来算，应该为 60-80% 的心率储备或 77-90%最大心率。 训练频率上，每周训练3天，每天运动 20-60min 是最佳选择。如果以较低强度训练时，其训练频率每周应超过3天，当然，每周训练次数的设定要取决于热量消耗的目标、个人的习惯以及日常生活作息时间等因素，每个人应该根据自己的情况制定。 最后，心肺功能的锻炼应遵循渐进原则，运动强度和持续时间应该逐渐增加，长此以往，就可有效地提高或保持最大摄氧量，达到减重和促进健康之目的。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:1","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"3.2 肌肉适能 肌肉适能是指机体依靠肌肉收缩克服和对抗阻力维持身体运动的能力，通常表现为肌肉力量、肌肉耐力和肌肉功率等方面。日常生活中的一些小事，如搬运重物、做家务、坐、走、跑、跳等都离不开肌肉适能。 肌肉力量是肌肉所能发挥的最大力量，比如拳击运动员出拳所释放的最大力量。肌肉耐力是肌肉持续工作的能力，比如长跑和限时仰卧起坐考研的就是肌肉耐力。肌肉功率是肌肉在短时间快速发挥其力量的能力（通常用爆发力作为指标）。因此，肌肉力量的评价技术通常包括卧推、负重蹲起、负重曲肘、俯卧屈膝、杠铃上举等；肌肉耐力的评价技术通常包括连续蹲起次数、曲臂支撑时间、1分钟俯卧撑、1分钟仰卧起坐、1分钟引体向上等；肌肉功率的评价技术包括立定跳远、深蹲跳、半蹲跳、多级跳、跳箱等。 肌肉适能主要受遗传、年龄、性别、体重、激素以及训练的影响，研究表明，绝对力量的遗传度为 35%，相对力量的遗传度高达 64%，不过，遗传因素只决定运动能力的起点，通过后天训练依然会有较大的提高。肌肉力量也随着年龄而变化，少年儿童肌肉组织中含水量较多，蛋白质、脂肪以及无机盐类较少，能量储备较差，因此肌肉力量较弱，男女达到最大肌肉力量的年龄分别是 25 岁和 22 岁，此后肌肉力量就会随着年龄增长而衰退。 抗阻训练可以改善肌肉适能，包括举重、弹力带、自重和器械训练等多种形式，主要是因为运动刺激一方面可以使身体的有氧耐力增强、肌纤维的横截面增大，另一方面可减少大脑皮层的抑制作用，增强肌群间的协调能力，进而在总体上提高肌肉力量和肌肉耐力。 男生训练肌肉时大致可以分为几个部分：胸部、手臂、腹肌、肩部、臀部、腿部和背部。其中 胸部由胸大肌、胸中肌、胸小肌等肌肉构成，常见的胸部训练动作有：哑铃卧推、宽距俯卧撑等。 手臂主要包括肱二头肌、肱三头肌及其它前臂肌群，常用训练动作有：哑铃锤式弯举、反握引体向上。 肩部主要由三角肌等肌肉构成，练肩能有效解决溜肩问题。常用训练动作有：哑铃侧前交替平举、弹力绳推举。 腿部肌肉主要包括四头肌和小腿肌群等。 腹肌主要包括腹直肌、腹外斜肌、腹内斜肌等，常用训练动作有悬垂抬腿。 臀部主要有臀大肌、臀中肌、臀小肌等，常用训练动作有负重臀桥、俯撑抬腿等。 改善肌肉适能的原则包括：持续训练、循序渐进、变换负荷、有效负荷和训练恢复。对于第三点，是因为人体对外来负荷刺激具有适应性，长时间使用同样的训练负荷和手段，锻炼效果就会越来越弱。负荷的变化体现在训练方式、负荷的量和强度等方面，在不影响训练效果的前提下，应当定期增加新的训练手段，一些常用的训练手段也应该采取间隔使用或不同组合的方式进行变化。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:2","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"3.3 柔韧性 柔韧性指人体关节在不同方向上的活动幅度，以及跨过该关节的肌肉、韧带、皮肤等软组织的弹性和伸展能力。以髋关节为例，可进行屈、伸、内收、外展、旋内、旋外等活动。良好的柔韧性可以降低肌肉受伤和酸痛的几率，也可以预防和矫正不良姿势。 影响柔韧性的生理因素主要有四种：关节面结构、肌肉、韧带组织的伸展性、关节周围组织的体积以及中枢神经系统对骨骼肌的调节能力。其中，关节面结构是由遗传决定的，其它三方面都可以后续锻炼。另外，温度增加也可以增大肌肉运动的范围和伸缩性，因此在寒冷的冬季人体会感觉柔韧性较差。 柔韧性的评价主要是通过测量身体有关部位完成动作时活动的幅度完成的，比如坐位体前屈等。柔韧性本身则通过全面的拉伸训练而保持，通常作为准备活动和整理活动的一部分。 准备活动（热身）的作用： 可以逐渐提高中枢神经系统的兴奋性，克服机体惰性 作为剧烈运动前的预热，可以增强机体的新陈代谢，保证体能的正常发挥 有助于改变血流方向，在正式运动时使更多血液流向肌肉，为肌肉输送更多的养料和氧气 可以提高肌肉和关节韧带的弹性，降低粘滞性，使关节腔内滑液增多，预防肌肉和韧带拉伤 运动完整理活动的作用： 有助于血液返回心脏，促进运动中代谢物的排出，加速运动后的体力恢复 通过舒展肌肉痉挛，缓解运动后的肌肉酸痛 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:3","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"3.4 身体成分 身体成分是指身体的构成成分。我们的身体由无脂肪组织（包括肌肉组织）和脂肪组织组成。一般来讲，人们会把身体成分的焦点放在肌肉以及脂肪的相对含量和比例上面，反映出来的就是更好的身材，也是人们追求的主要目标。 身体成分通常用 BMI 表征，BMI = 实际体重（kg）/身高(m^2)，其中，18.5 \u003c= BMI \u003c 22.9 为正常体重。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:4","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"4. 饮食、睡眠及压力管理 从阴阳平衡的角度看，如果健身为阳，那么饮食、睡眠及压力管理就是阴，都是追求健康过程中不可缺少的一环。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"4.1 饮食 健康饮食不是只选择那些没有吸引力的食物，完全可以既美味又富含营养，中国营养学会每5年发布一版《中国居民膳食指南》，会针对国人的特点提出相应的建议。 健康的饮食模式应该包括蔬菜、水果、谷物（至少一半的全谷类）、脱脂或低脂的食物，以及多样化的蛋白质食物（如海鲜、瘦肉、家禽、蛋类、豆类、坚果类、种子类以及大豆制品）。同时，应控制饱和脂肪、反式脂肪、添加的糖类以及钠的摄入。上述策略可以个性化，以符合个人的健康需求、饮食喜好及传统习俗，而不必规定单一的、严苛的饮食模式。重点在于合理、灵活地搭配各种食物，从而建立健康的饮食模式。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:1","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"4.2 睡眠 睡眠对于我们身体各项功能的正常运行至关重要。相关功能如下 睡眠期间，心率和血压会自然波动，以促进心血管健康。 深度睡眠期间，由于生长激素的分泌，细胞和组织得以修复。 通过产生靶向性细胞因子，身体的免疫功能得到提高。 与食欲相关的荷尔蒙会产生变化（抑制食欲的瘦素增加，而刺激食欲的胃饥饿素减少）。 睡眠不足会使日常工作如学习、集中精力和反应更加困难。那么怎样判断自己的睡眠是否充足呢？白天打瞌睡是缺乏睡眠的一个非常简单却很明显的指标，表明身体需要更多的睡眠。白天明显的困倦表明需要更多或更好的睡眠，或者两者兼而有之。另外，观察和记录自己的睡眠习惯和睡眠状况的变化趋势会带来很大的帮助。 一些改善睡眠的小技巧如下 每天坚持按时睡眠，包括周末时间。 执行一种能让自己放松下来的睡眠仪式。 每天坚持体育锻炼。 保证卧室有理想的温度、声音和光线。 在舒适的床垫和枕头上睡觉。 当心那些可以影响睡眠的物质，比如酒精和咖啡因。 睡前关闭所有的电子设备。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:2","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"4.3 压力管理 什么是压力？从最基本的层面来讲，压力是大脑对需求的反应。不是所有的压力都一样，它可以被划分成很多种，包括急性压力、发作性急性压力和慢性压力。 急性压力源自最近发生的事件，或不久的将来要发生的事件所产生的需求和压力。其压力源是短期的，比如弄丢了汽车钥匙，或者要处理客户的投诉。处于这种压力中的常见症状包括情绪易怒、暴躁、焦虑、紧张性头痛、肌肉紧张、消化系统问题，以及其他生理反应，包括血压升高、心率加快、出汗，甚至呼吸急促或胸痛。 发作性急性压力常发生在急性压力频繁出现时。想象一下，一个人担子太重，任务太多，他总是匆匆忙忙，又总是迟到。似乎永远在一个危机结束时又迎接下一个危机，或遭受持续的困扰。承受发作性急性压力的症状包括持续的紧张性头痛、偏头痛、高血压、胸部疼痛和心脏病。 慢性压力是持续性的、很折磨人的压力，它会无情地、长时间地困扰我们。未经处理好的慢性压力所引发的健康问题包括焦虑、失眠、肌肉疼痛、高血压及抵抗力降低。另外，压力还会引发心脏病、抑郁症和肥胖病。 面对短期压力，人们通常在对特定的情况做出反应之后就回到放松的基本状态。长期压力比较麻烦，因为我们的身体会长期处于警戒状态。这种状况相当于我们为身体启动了“冲刺”装置，时刻准备一触即发（见下面的“战斗或逃避反应”），迫使身体一直处于“马拉松式”或持续的紧张状态，时间久了就会导致身体崩溃或者系统衰竭。压力影响着我们身体的每个系统，比如我们的肌肉与骨骼系统会出现肌肉紧张；消化系统会出现腹泻或便秘；内分泌系统会出现应激激素分泌增加和血糖水平升高；另外，也会增加心血管系统中高血压、心脏病及中风的发作风险。 在生活中未雨绸缪，提前准备应对生活中可能出现的状况有助于防止压力给我们带来负面影响。当然，不是所有的压力都能够被避免，因此，有效控制自己对压力的反应尤为重要。经常用来帮助应对压力的有效方法就是有规律地参加体育锻炼和健康饮食。此外，下面的小技巧也可以用来防止或管理压力 给自己安排一份时间表。记得并执行日程安排可以帮助减少紧急情况带来的压力感。 避免拖延。提前有序地完成工作任务可以有效避免压力。 做深呼吸放松。有意识地减慢呼吸频率，并加深每一次呼吸有助于消除在面临压力时通常会出现的快速呼吸和浅呼吸。 控制酒精的摄入。尽管酒精有暂时缓解压力的作用，但长期依赖酒精减压有非常大的副作用，并且会产生更多的身体压力。 跟家人或朋友聊天。跟信任的人聊一下带来压力的事情很有好处。这不仅仅是因为它能帮助我们“摆脱烦恼”，还可能会得到有用的建议。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:3","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"5. 规律锻炼的技巧 开启锻炼，以及要取得良好的锻炼效果，需要科学的锻炼计划。这个锻炼计划除了包括一个明确的锻炼目标，还需要确定锻炼项目、锻炼强度、锻炼频率和每次锻炼的时间。其中，锻炼项目应根据锻炼目的选择，改善心肺一般选择有氧运动，强壮肌肉则选择力量训练。最后，锻炼计划还需要适时的评价与调整。但要注意，锻炼计划并不是精确的公式，它有点像菜谱，虽然列举了各种食材和配料，但烹饪过程中每个人依然有自己的习惯，因此每个人的锻炼计划都是独一无二的，应该根据自己的健康状况、现有运动水平和健身目标指定适合自己的计划。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"5.1 评价锻炼计划的参数 体力活动的定量测量最常用的指标是锻炼强度、锻炼时间和锻炼频率2。 运动强度的评价方式有很多，比如最大摄氧量、自我感觉、代谢当量等，但最容易操作的方式是根据心率判定。心率，即每分钟心脏跳动的次数。在一定范围内（100～180次/分），心率与运动强度呈直线关系，所以心率可以反映运动的强度。由于心率受年龄、身体状况、训练水平和性别等多方面影响，因此实际应用时，通常采用最大心率百分比的方式对运动强度分级，最大心率可按照 220-年龄（岁）来计算。比如，20 岁的健康成年人，最大心率=220-20=200（次/分）。一般而言，运动时心率在 40%～54% 最大心率范围内为小强度；在55%～69%最大心率范围为中等强度；而运动时心率大于70%的最大心率为大强度。如要减肥，对年轻人而言，一般运动强度控制在60%～75%的最大心率，则对脂肪的消耗比较有效3。 锻炼时间指每次运动的时间，长短根据运动种类和个人身体情况确定。经常参加体育锻炼的人，每次锻炼的有效运动时间应达到 30-60min。初次参加体育锻炼的人，建议按如下方式确定：第一周 10-15 min，第二周 15-20 min，第三周 20-25 min，第四周及以后达到 30-60 min，还要注意，每次锻炼前后应有 5-10 min 的准备活动和整理活动。 运动频率指每周参加锻炼的次数，每周 1 次锻炼效果不大，2 次可累计，3 次运动效果明显，增加到 4-5 次锻炼效果依然可以提高，但终止体育锻炼，已获得的健身效果会以获得效果 1/3 的速度消失，所以要坚持锻炼。有体育锻炼习惯的人，每周锻炼频率应在 3 次以上，初次参加可遵循下面的原则，第一周 1-2 次，第二周 2-3 次，第三周及以后 3 次及以上。 ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:1","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自我提升"],"content":"5.2 锻炼目标的制定 忽视运动要素中的任何一项都会使健身计划失去平衡，因此，为了改善个人健康或达到健身目标，有氧、肌力和肌耐力、柔韧性都需要得到锻炼。下表列出了一些基于体力活动的有氧耐力及抗阻训练的目标指导 体力活动水平 有氧训练重点 抗阻训练重点 初级（体力活动不足或几乎没有体力活动，后者被划分为未进行过锻炼者） 未进行过锻炼者：重点是每天进行 20-30 分钟低至中强度的活动。也可以每次持续 10 分钟，累计完成。总的来说，一周内的目标是 60-100 分钟。 之前有少量体力活动者（即一旦达到每周 60-100 分钟的目标）：重点是每天进行 30-45 分钟低至中强度的活动，也可以每次持续 10 分钟，累计完成。每周总目标为 100-150 分钟。 选择6种动作（分别针对以下部位的肌肉：髋部和腿部、胸部、背部、肩部、下背部及腹部）。开始时每周 2 次，每个动作 1 组，每组重复 10-15 次，随着个人的进步，可以把目标定为每周训练 2-3 次，每个动作 8-12 次，1-2 组（注意：对于抗阻训练经验不足的中老年人来说，建议每组重复 10-15 次） 中级（有一定的体力活动，但总体来说还处于中等水平） 中等水平者：重点是每天 30-60 分钟中强度的活动，每周的总目标是 150-250 分钟。 选择 10 种动作（分别针对以下部位的肌肉：髋部和腿部、股四头肌、腘绳肌、胸部、背部、肩部、肱二头肌、肱三头肌、下背部和腹部）。训练目标为：每周训练 2-3 天，每次 2 组，每组重复 8-12 次（注意：对于抗阻训练经验不足的中老年人来说，建议每组重复 10-15 次） 有运动习惯（会定期有规律的进行中至较高强度的锻炼） 定期锻炼者（中至较高强度）：重点是每天进行 30-90 分钟中至较高强度运动。每周总的目标是进行 150-300 分钟的活动（持续时间取决于运动强度） 可以继续中级水平的方案（一旦适应了负荷，应增加重量），也可以把运动方案拆开练习，在某一天专门联系某个肌肉群。 重复次数和组数是抗阻训练的两个重要指标，以举重为例，重复一次指举重的一次动作，举起某个重量再乘以连续完成动作的次数称为一组。对于每个肌肉群都应该进行几组训练。可以重复做某个动作，也可以选择不同的动作来训练同一个肌肉群。重复次数和组数取决于目标。通常来说，抗阻训练应完成 2～4 组，每组每个动作重复 8～15 次。对于那些专门针对肌肉耐力的抗阻训练，重复次数一般会增多（如 15～25 次），比如，像俯卧撑这样的自重练习，就可以 25 个一组，多做几组。 为了提高肌肉适能，必须对肌肉和肌肉群进行超负荷训练。抗阻训练过程中，相对强度与动作的重复次数和完成组数息息相关。如果不能够一次性重复完成 8 次规定的训练动作，那么说明使用的重量或阻力太大了。如果能够一次完成 15 个以上的规定动作，那么使用的重量或阻力可能太轻了。当刚开始锻炼的时候，我们会发现需要不断调整。 合理休息是肌肉能够产生适应性改变的关键。在制定抗阻训练方案时，不要连续两天训练同一肌肉群。开始时，可能会出现肌肉酸痛的情况，但随着训练的推进，这种情况会降到最低。 王香生,黄雅君.体力活动与健康:研究及应用[J].体育与科学,2008(06):76-78+55. ↩︎ 田野,陆一帆等.国民运动健身科学指导系统研究与建立[J].体育科学,2010,30(02):3-10. ↩︎ 王剑，如何为运动计算强度，科学网，2015.05 ↩︎ ","date":"2023-04-09","objectID":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:2","tags":["健身"],"title":"健身-基础知识","uri":"/%E5%81%A5%E8%BA%AB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["自然科学"],"content":"本文介绍静力学中几个基本的物理量及其计算公式。 相互作用（静力学）的分类如下： 万有引力 重力 电磁相互作用 压力、弹力、摩擦力 弱相互作用 $\\beta$ 衰变（一个中子突然扔出去一个电子，然后自己变成一个质子，中间还会释放出中微子。整个这个过程中，会有一种相互作用在其中，这个相互作用就是弱相互作用） 强相互作用 夸克和夸克之间的相互作用，作用有剩余的就转变为强子和强子之间的相互作用，也就是强相互作用 质能方程： $$E = mc$$ 其中E是能量，单位和功的单位一致（焦耳J）。m 是质量，c 是光速。 ","date":"2023-04-05","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/:0:0","tags":["物理"],"title":"初等物理02-静力学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/"},{"categories":["自然科学"],"content":"物理量 重力 重力是万有引力的一部分。 重力不等于万有引力，还差了向心力。 重力的大小=mg，m 是质量、g 是重力加速度。 重力的方向竖直向下。 重力的作用点不等于重心，重力作用在每一个有质量的点上。 重心 是重力的等效作用点，原理是杠杆原理。 求重心的方法： 对于平板状物体，可采用悬挂法 对于几何形状规则、质量分布均匀的物体其重心就是它的几何中心。 性质：重心必须在支持面以上 弹力 本质上弹力是电磁相互作用。 弹力的方向是垂直于接触面、指向受力物体（恢复形变的方向）。 压力、支持力都是弹力。 因为物质都是由分子、原子这样的物质组成。原子核的周围围绕了电子。量子力学告诉我们，我们没有办法确定电子的位置。电子可能出现在原子核的任何方位，如果用高速照相机将电子的位置记录下来，那么这些电子的轨迹是密密麻麻的，就像一团云。这就是电子云。电子云和电子云之间有很强烈的排斥作用，这种排斥作用被称为泡利不相容原理。 弹簧弹力大小： $$\\overrightarrow{F} = -k\\overrightarrow{x}$$ 其中，x 表示弹簧偏离平衡位置的位移，k 表示弹簧的劲度系数。 该公式也被称为胡克定律。 弹性 物理含义是标志着物体受到外力作用恢复形变的能力。 弹性限度 一旦超过就不能恢复。 形变 形变包括：拉伸、压缩、弯曲、扭转、剪切。 摩擦力 摩擦力的本质也是电磁相互作用。 产生摩擦力的前提条件： 两个物体有接触，并有一定的压力。 物体表面不是绝对光滑。 有相对运动趋势。 摩擦力的分类： 静摩擦力，通过平衡条件来判断大小。 最大静摩擦力：$f_{max}=\\mu mN$ 滑动摩擦力：$f=\\mu N$ 滚动摩擦力：约等于0，远远小于同接触面的滑动摩擦力 其中 $\\mu$ 为摩擦因数、N 为压力、f 为摩擦力。 这意味着物体的摩擦力与施加在其上的压力成正比。 基本物理量 基本物理量 基本物理单位 长度 米 质量 千克 时间 秒 温度 开尔文温度 光 坎德拉 电流 安培 物质的量 摩尔 开尔文温度：如果所有的微观运动都达到静止，此时的摄氏温度达到 -237.15 度，取该温度为绝对零度，也即开氏温度的零度，并以一个摄氏温度为单位长度，这就是开氏温度。 ","date":"2023-04-05","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/:1:0","tags":["物理"],"title":"初等物理02-静力学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/"},{"categories":["自然科学"],"content":"力的正交分解 步骤： 平移，使矢量的开始点与原点重合。 从矢量的结束点向两轴做垂线。 从原点到垂足间连分力（大小靠三角函数计算）。 ","date":"2023-04-05","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/:2:0","tags":["物理"],"title":"初等物理02-静力学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/"},{"categories":["自然科学"],"content":"力与运动的关系—牛顿定律 牛顿第一定律（惯性定律） 任何物体都要保持匀速直线运动或静止状态，直到外力迫使它改变运动状态为止。 惯性：保持原有运动状态的能力。 惯性的直接决定因素：质量 m。 牛顿第二定律（力的作用效果） 物体加速度的大小跟作用力成正比，跟物体的质量成反比，且与物体质量的倒数成正比；加速度的方向跟作用力的方向相同。 即公式： $$F = ma$$ 其中 F 表示作用在物体上的力，m 表示物体的质量，a 表示物体的加速度。 证明如下： 根据生活常识易得 F 与 m、a 成正比，即有：$ F = kma$ ，若取 $m=1kg$、$a = 1m/s^2$ ，则牛顿被定义为：$1 N = 1kg * 1m/s^2$ 也就解释了为什么 $1 N/kg = 1m/s^2$ 牛顿第三定律（作用力与反作用力） 作用力与反作用力的特点：等大、反向、共线、异体、同时、力的性质相同。 区别于平衡力，一对平衡力的特点：等大、反向、共线、作用于同一物体、同时、力的性质不同。 ","date":"2023-04-05","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/:3:0","tags":["物理"],"title":"初等物理02-静力学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/"},{"categories":["自然科学"],"content":"牛顿定律的应用 超重与失重 电梯在上升，人在电梯里称体重。体重计上的数值增加了，因为牛顿第二定律说明：$N-mg=ma$，即 $N=m(g+a)$。这种现象被称为超重现象，但人的重力是不变的，而弹力增加了，这种弹力被称为视重，也就是看起来的重量。 反之，称为失重，即 $mg-N=ma$，进而有 $N=m(g-a)$。 特别的，当 $a=g$ 时，称为完全失重。当 a 大于 g 时，物体会漂浮，这种现象称为反重力。 ","date":"2023-04-05","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/:4:0","tags":["物理"],"title":"初等物理02-静力学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8602-%E9%9D%99%E5%8A%9B%E5%AD%A6/"},{"categories":["自然科学"],"content":"开这个篇章是因为最近在读《网络是怎样连接的》，其中介绍到物理层的时候，有介绍道用电磁波的Wi-Fi、用光波的光纤等。然后因为自己的工作也是跟电挂钩的，多多少少要接触到一些。所以决定还是好好补一补高中物理知识（没有上过高中，感觉很多是常识的东西自己都不知道），不为考试，不求学的有多出神入化，只有最纯粹的求知欲。 全程是跟着学而思的网课在走，后期可能学完会补充一点大学里的物理知识在内，先开个坑吧。 因为学习的时候是在上下班通勤的地铁上，不方便记笔记（都是用手打在微信的笔记里），所以文章也没什么逻辑可言，只是想记录自己的学习过程，并把一些琐碎的知识归纳集中到一起。 下面就正式开始，首先是运动学。 ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:0:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["自然科学"],"content":"物理量 位移 矢量，值为 $\\Delta x_2-x_1$。物理含义是一个物体从一点到另一点移动的方向和距离。 速度 矢量，值为$\\frac{位移}{时间}$。速度的大小称为速率。 瞬时速度 时间趋于 0 的速度。 平均速度 矢量，值为$\\frac{总位移}{总时间}$。 平均速率 标量，值为$\\frac{总路程}{总时间}$。 加速度 矢量，值为$\\dfrac{\\Delta v}{\\Delta t}$。方向为 v-t 图中的斜率，斜率为正表示加速，斜率为负表示减速。 音速：331m/s 光速：299792458m/s 近似于$3\\times10^8$ 速度的意义： 物体运动的快慢 单位时间内所走的位移 时间中点速度 当你走了一半的时间时的速度。计算公式如下： $$V_\\frac{t}{2} = \\overline{V} = \\dfrac{V_0 + V_t}{2}$$ 其本质就是平均速度。 位移中点速度 当你走了一半的路程时候的速度。其计算公式如下： $$V_\\frac{x}{2} = \\sqrt{\\dfrac{V_t^2 + V_0^2}{2}}$$ 该公式可用加速度公式中的第四个公式推导，被称为方均根。 ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:1:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["自然科学"],"content":"图像法 x-t 图 x-t 图是用于描述位移和时间的图。 横坐标：时间 纵坐标：位移 截距：初始位置；移动到原点所需要的时间： 斜率：任意一点（切线）的斜率即为该点的速率（瞬时速度） 交点：两物体在一个一维运动（直线运动）中相遇 面积：无意义 水平线：表示静止 斜直线：表示匀速直线运动 那么匀速运动可定义为： v 矢量不变 任意相等时间内$\\Delta x$都相同（x-t 图中图像的任意一点斜率均相同） 匀速率运动是速度的大小不变，但是方向可变。因此和匀速运动不是一回事。 v-t 图 v-t 图是用于描述速度和时间的图。 横坐标：时间 纵坐标：速度 截距：初始速度大小（默认讨论一维运动速度大于零代表方向和正方向一致）；减速到某一时刻时速度大小为零； 斜率：加速度 交点：达到瞬时共速，即速度大小相同 交差的面积：相对位移 面积：表示位移 水平线：表示匀速直线运动 斜直线：表示匀加速或匀减速运动 那么匀变速直线运动可以表示为： a 矢量不变 任意相等时间内$\\Delta v$都相同 匀变：a不变 匀加：a不变，且v与a方向相同 匀减：a不变，且v与a方向相反 小技巧 v 的方向看象限，v 的图像在第一象限为正，第四象限为负。 a 的方向看斜率，斜率大于零为正，斜率小于零为负。 ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:2:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["自然科学"],"content":"公式 加速度公式 $V_t = V_0 + at$ $x = V_0 t + \\dfrac{at^2}{2}$ $x = \\dfrac{V_0 + V_t}{2} \\times t$ $x = \\dfrac{V_t^2 - V_0^2}{2a}$ $x = V_t \\times t - \\dfrac{at^2}{2}$ 其中，$V_0$表示初速度、$V_t$表示末速度、a 表示加速度、t 表示时间段、x 表示位移。 ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:3:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["自然科学"],"content":"定理 相邻相等时间间隔下的匀变速运动 静止状态下（$V_0 = 0$）开始的匀变速直线运动，相邻相等时间间隔下其位移之比为：$1:3:5:7…$ 只要是匀变速直线运动，那么对于相邻相等时间间隔 T，有：$X_{i+1} - X_i = \\Delta X = aT^2$ ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:4:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["自然科学"],"content":"定义 自由落体运动 条件： $V_0 = 0$ $a = g$，并且方向竖直向下（等价说法是除重力外不受其他力作用） $g = 9.8 N/kg = 9.8 m/s^2$ 平抛运动 平抛运动是一个水平方向为匀速直线运动、竖直方向为自由落体运动的矢量合成。是一个匀变速曲线运动。 条件： 水平方向的初速度，大小不为零 竖直方向的加速度，大小为g ","date":"2023-04-01","objectID":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/:5:0","tags":["物理"],"title":"初等物理01-运动学","uri":"/%E5%88%9D%E7%AD%89%E7%89%A9%E7%90%8601-%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的结构体与方法。 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"1. 结构体 结构体是一种非常重要的结构，用到的地方非常多，在 Go 中，结构体还是实现面向对象编程的基础。 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"1.1 定义与初始化 结构体定义方式如下： type identifier struct { field1 type1 field2 type2 ... } 大括号中的每一行称为一个字段，每个字段都有一个类型和一个名字，在一个结构体中，字段名必须是唯一的。结构体名和字段名的命名遵循可见性规则，即使用首字母的大小写来表示可导出和不可导出。但是需要注意，一个可导出的结构体类型中可以存在不可导出的字段。 结构体的字段可以是任意类型，甚至可以是结构体本身、函数或者接口。一个简单的结构体定义示例如下： type T struct { a,b int } 结构体是自定义数据类型，因此我们可以像基本数据类型一样声明/定义一个结构体类型的变量，声明时会分配内存并默认使用每个字段类型的零值来初始化。我们也可以手动初始化一个结构体，使用点号符给字段赋值，示例如下。另外，访问结构体内字段的值时同样使用点号符，这种使用点号符赋值和获取字段值的方式叫做选择器(selector)： var s T s.a = 5 s.b = 8 由于结构体也是值类型，使用 new 函数创建。注意，使用 new 得到的 t 是指向结构体的指针： var t *T = new(T) t := new(T) // 简单方便地写法，最常用 至此我们注意到，使用结构体时我们可能遇到两种类型：结构体类型和结构体指针类型，这两种类型都可以通过选择器的方式来使用，如下，v.i 和 p.i 都可以得到正确的值，在理解的时候可以想象底层对结构体指针 p 自动做了解引用，如 (*p).i。 type myStruct struct { i int } var v myStruct // v是结构体类型变量 var p *myStruct // p是指向一个结构体类型变量的指针 v.i p.i (*p).i 除使用选择器初始化结构体字段外，一种更简短更常用的结构体初始化方法如下： ms := struct1{10, 15.5, \"Chris\"} // 结构体类型 ms := \u0026struct1{10, 15.5, \"Chris\"} // 结构体指针类型 ms := \u0026struct1{f1:15.5，i1:10} // 括号内声明字段名，这样可以不按定义的字段顺序，甚至省略部分字段 其中第二行称为混合字面量语法，但底层仍然会调用new()，因此与使用 new() 初始化是等同的。 以type Point struct {x,y int}为例，这几种初始化方式的内存布局如下： 从上图可以看出，结构体和它包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套其它的结构体，同样如此。 type Rect1 struct {Min, Max Point } type Rect2 struct {Min, Max *Point } 如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：size := unsafe.Sizeof(T{})。 一个使用结构体的完整例子如下： package main import \"fmt\" type struct1 struct { i1 int f1 float32 str string } func main() { ms := new(struct1) ms.i1 = 10 ms.f1 = 15.5 ms.str= \"Chris\" fmt.Printf(\"The int is: %d\\n\", ms.i1) fmt.Printf(\"The float is: %f\\n\", ms.f1) fmt.Printf(\"The string is: %s\\n\", ms.str) fmt.Println(ms) } // Output: // The int is: 10 // The float is: 15.500000 // The string is: Chris // \u0026{10 15.5 Chris} ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:1:1","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"1.2 结构体标签 实际上，一个完整的结构体定义，在字段名和类型外，还有一个标签(tag)部分。标签是一个附属于字段的字符串，用来对字段进行一定的说明，对程序功能没有太大的作用。标签只有包 reflect 能获取（将在下一章介绍）。 package main import ( \"fmt\" \"reflect\" ) type TagType struct { // tags field1 bool \"An important answer\" field2 string \"The name of the thing\" field3 int \"How much there are\" } func main() { tt := TagType{true, \"Barak Obama\", 1} for i := 0; i \u003c 3; i++ { refTag(tt, i) } } func refTag(tt TagType, ix int) { ttType := reflect.TypeOf(tt) ixField := ttType.Field(ix) fmt.Printf(\"%v\\n\", ixField.Tag) } // Output: // An important answer // The name of the thing // How much there are ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:1:2","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"1.3 匿名字段与内嵌结构体 结构体的字段名其实和变量很相似，不需要时也可以用空白符 _ 代替，但实际上，也可以直接省略，即整个字段只有类型，此时类型就是字段名，这种字段叫做匿名字段。如下例，通过类型 t.float32 来获取存储在匿名字段中的数据，也因为这种调用方式，一个结构体中对每一种数据类型只能有一个匿名字段： package main import \"fmt\" type T struct { a int float32 // anonymous field } func main() { t := T{6, 7.5} fmt.Println(t.float32) } // Output: // 7.5 由于结构体本身也是一种数据类型，因此也可以作为匿名字段使用，称为内嵌结构体。通过内嵌结构体可以实现面向对象编程中的继承。 package main import \"fmt\" type A struct { ax, ay int } type B struct { A bx, by float32 } func main() { b := B{A{1, 2}, 3.0, 4.0} fmt.Println(b.ax, b.ay, b.bx, b.by) // 可以直接调用 A 中的内容 fmt.Println(b.A) } // Output: // 1 2 3 4 // {1 2} 使用内嵌结构体的时候，很可能会出现命名冲突（继承来的字段名和当前结构体的某个字段名相同），这种情况下： 外层的名字会覆盖内层的名字，但两者的内存空间都会保留，这种特性提供了一种重载字段或方法的方式。 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。 下例中b.b的调用不会出错，指的是 b.b，而不是b.A.b（因为它们不在同一层，外层会覆盖内层），进行内层调用可以使用b.A.b： type A struct {a, b int} type B struct {A; b float32} var b B 但下面这种情况，c.a的调用会导致编译器错误，只能由程序员手动修改（因为在同一层，没法判断是 c.A.a 还是 c.B.a）。 type A struct {a int} type B struct {a, b int} type C struct {A; B} var c C ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:1:3","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"1.4 结构体工厂 可以为结构体定义一个工厂来创建结构体实例，工厂的名字通常以 new 或 New 开头，这是一种很常用的方法。假设定义了如下 File 结构体类型： type File struct { fd int //文件描述符 name string //文件名 } 下面是为 File 结构体创建的工厂，返回一个指向结构体的指针： func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } return \u0026File{fd, name} } 然后这样调用它： f := NewFile(10, \"./test.txt\") 在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便地实现构造函数。这种方式可以模拟面向对象编程中使用new的实例化。如果要强制使用工厂方法，需要利用可见性规则禁止使用 Go 内置的new()函数： type matrix struct { // 小写字母开头 对外部不可见 ... } func NewMatrix(params) *matrix { m := new(matrix) // 初始化 m return m } 然后在其它包里就只能使用工厂创建结构体实例： package main import \"matrix\" ... wrong := new(matrix.matrix) // 编译失败（matrix 是私有的） right := matrix.NewMatrix(...) // 实例化 matrix 的唯一方式 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:1:4","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2. 方法 Go 中的方法是作用在 “接收者” 上的一个函数，接收者是某种类型的变量。定义方法的一般格式如下： func (recv recesiver_type) methodName(parameter_list) (return_value_list) { ... } 在func关键字之后，方法名之前的括号中声明接收者和接收者类型。同样还可以看到，方法的本质仍然是函数，只不过是针对特定变量的函数，除了括号中的接收者声明，其它部分和普通函数没有不同。 接收者几乎可以是任何类型的变量，包括基本数据类型、数组的别名类型、结构体、函数等，但不可以是接口，因为方法是需要实现的，而接口只是抽象定义。 如果接收者变量recv已经在其它地方进行了初始化，Method1 是它的方法名，那么方法的调用格式为recv.Method1()，同结构体相似，如果recv是指针，调用时自动解引用。 如果方法不需要使用recv的值，可以用空白符_替换它 func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... } 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）。 一个接收者变量加上它的方法等价于面向对象中的一个类，区别只在于 Go 中方法的代码与变量定义是分离的，只要在同一个包中即可。 因为方法是函数，所以方法同样不允许重载，但不同的接收者变量可以有相同名字的方法，即使它们在同一个包中，一个例子如下： func (a *denseMatrix) Add(b Matrix) Matrix func (a *sparseMatrix) Add(b Matrix) Matrix 一个结构体方法的例子如下： package main import \"fmt\" type TwoInts struct { a int b int } func main() { two1 := new(TwoInts) two1.a = 12 two1.b = 10 fmt.Printf(\"The sum is: %d\\n\", two1.AddThem()) fmt.Printf(\"Add them to the param: %d\\n\", two1.AddToParam(20)) two2 := TwoInts{3, 4} fmt.Printf(\"The sum is: %d\\n\", two2.AddThem()) } func (tn *TwoInts) AddThem() int { return tn.a + tn.b } func (tn *TwoInts) AddToParam(param int) int { return tn.a + tn.b + param } // Output: // The sum is: 22 // Add them to the param: 42 // The sum is: 7 一个非结构体类型（切片别名）方法的例子如下： package main import \"fmt\" type IntVector []int func (v IntVector) Sum() (s int) { for _, x := range v { s += x } return } func main() { fmt.Println(IntVector{1, 2, 3}.Sum()) // 输出是6 } 变量和定义在它上面的方法必须在同一个包里定义，如下例是错误的，这也是为什么不能定义 int 这样的基本类型的方法，但可以定义基本类型的别名的方法： package main import \"container/list\" func (p *list.List) Iter() { // ... } func main() { lst := new(list.List) for _= range lst.Iter() { } } ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2.1 函数和方法的区别 函数将变量作为参数：Function1(recv) 方法在变量上被调用：recv.Method1() 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。 不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called 接收者必须有一个显式的名字，这个名字必须在方法中被使用。 receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:1","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2.2 指针或值作为接收者 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。一个例子如下： package main import ( \"fmt\" ) type B struct { thing int } func (b *B) change() { b.thing = 1 } func (b B) write() string { return fmt.Sprint(b) } func main() { var b1 B // b1是值 b1.change() fmt.Println(b1.write()) b2 := new(B) // b2是指针 b2.change() fmt.Println(b2.write()) } // 输出： // {1} // {1} 指针方法和值方法都可以在指针或非指针上被调用，如上例，b1是值类型，而 change() 方法作用在指针类型上，b1.change() 会被自动转换为 (\u0026b1).change()；b2 是指针类型，但 write() 方法是值类型，b2.write() 会被自动转换成 (*b2).write()。 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:2","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2.3 利用方法读取结构体中的未导出字段 本文开始对结构体的介绍中，提到结构体对外部可见，而结构体中的字段对外部不可见是可能发生的，对于这种情况，读取或修改结构体中的字段值可以通过作用在结构体上的方法完成，提供 getter() 和 setter() 方法。对于 setter() 方法使用 Set... 前缀，对于 getter() 方法只使用成员名。一个例子如下： package person type Person struct { firstName string lastName string } func (p *Person) FirstName() string { return p.firstName } func (p *Person) SetFirstName(newName string) { p.firstName = newName } 对其中定义的结构体字段进行调用： package main import ( \"./person\" \"fmt\" ) func main() { p := new(person.Person) // p.firstName undefined // (cannot refer to unexported field or method firstName) // p.firstName = \"Eric\" p.SetFirstName(\"Eric\") fmt.Println(p.FirstName()) // Output: Eric } ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:3","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2.4 内嵌类型的方法与继承 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法 ， 这个机制提供了一种简单的方式来模拟面向对象语言中的子类和继承相关的效果。一个示例如下： package main import ( \"fmt\" \"math\" ) type Point struct { x, y float64 } func (p *Point) Abs() float64 { return math.Sqrt(p.x*p.x + p.y*p.y) } type NamedPoint struct { Point name string } func main() { n := \u0026NamedPoint{Point{3, 4}, \"Pythagoras\"} fmt.Println(n.Abs()) // 打印5 } 使用同名方法可以覆盖父类型中的方法，比如在上例中添加如下代码，会打印 100： func (n *NamedPoint) Abs() float64 { return n.Point.Abs() * 100.0 } 因为一个结构体可以嵌入多个匿名类型，所以实际上可以实现简单的多重继承，如下例所示： package main import ( \"fmt\" ) type Camera struct{} func (c *Camera) TakeAPicture() string { return \"Click\" } type Phone struct{} func (p *Phone) Call() string { return \"Ring Ring\" } type CameraPhone struct { Camera Phone } func main() { cp := new(CameraPhone) fmt.Println(\"Our new CameraPhone exhibits multiple behaviors...\") fmt.Println(\"It exhibits behavior of a Camera: \", cp.TakeAPicture()) fmt.Println(\"It works like a Phone too: \", cp.Call()) } // Output: // Our new CameraPhone exhibits multiple behaviors... // It exhibits behavior of a Camera: Click // It works like a Phone too: Ring Ring ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:4","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"2.5 在类型中嵌入功能 主要有两种方法来实现在类型中嵌入功能： A. 聚合（或组合）：包含一个所需功能类型的具名字段。 B. 内嵌：内嵌（匿名地）所需功能类型，像 2.4 所演示的那样。 假设有一个 Customer 类型，我们想让它通过 Log 类型来包含日志功能，Log 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 Log 类型，然后将它作为特定类型的一个字段，并提供 Log()，它返回这个日志的引用。 使用聚合方式实现如下： package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string log *Log } func main() { c := new(Customer) c.Name = \"Barak Obama\" c.log = new(Log) c.log.msg = \"1 - Yes we can!\" // shorter c = \u0026Customer{\"Barak Obama\", \u0026Log{\"1 - Yes we can!\"}} // fmt.Println(c) \u0026{Barak Obama 1 - Yes we can!} c.Log().Add(\"2 - After me the world will be a better place!\") // fmt.Println(c.log) fmt.Println(c.Log()) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) Log() *Log { return c.log } // Output: // 1 - Yes we can! // 2 - After me the world will be a better place! 使用内嵌方式实现如下： package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string Log } func main() { c := \u0026Customer{\"Barak Obama\", Log{\"1 - Yes we can!\"}} c.Add(\"2 - After me the world will be a better place!\") fmt.Println(c) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) String() string { return c.Name + \"\\nLog:\" + fmt.Sprintln(c.Log) } // Output: // Barak Obama // Log:{1 - Yes we can! // 2 - After me the world will be a better place!} 内嵌的类型不需要指针，Customer 也不需要 Add 方法，它使用 Log 的 Add 方法，Customer 有自己的 String 方法，并且在它里面调用了 Log 的 String 方法。 如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。 因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。 ","date":"2023-03-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/:2:5","tags":["Golang语法基础"],"title":"Golang语法基础7-结构体与方法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%96%B9%E6%B3%95/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的函数。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"1. 函数声明与定义 Go 中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为： func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) 定义就需要添加大括号和函数体： func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) { ... } 两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。 当函数执行到代码块最后一行，也就是最后一个 } 之前，或者执行到 return 语句的时候就会退出。 main 函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有 init() 函数会先执行该函数。 main 函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main 函数一旦返回就表示程序已成功执行并立即退出。同样，init() 函数也没有返回值。 Tips 函数参数、返回值以及它们的类型被统称为函数签名。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"2. 函数调用 同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示： pack1.FunctionName(arg1, arg2, ..., argn) pack1 是包名，FunctionName 是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下： package main func main() { println(\"In main before calling greeting\") greeting() println(\"In main after calling greeting\") } func greeting() { println(\"In greeting: Hi!!!!!\") } // Output: // In main before calling greeting // In greeting: Hi!!!!! // In main after calling greeting Tips 函数一般是在其他函数里面被调用的，这个其他函数被称为调用函数 (calling function)。理论上，函数调用其他函数的次数是无穷的（直到函数调用栈被耗尽）。 注意 函数重载 (function overloading) 指的是可以编写多个同名函数，只要它们拥有不同的形参/或者不同的返回值，在 Go 里面函数重载是不被允许的。这将导致编译错误。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3. 函数参数与返回值 除了 mian() 和 init() 函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以 return 或 panic 语句结尾，return 可以返回多个值，多值返回是 Go 的一大特性。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3.1 参数传递类型 Go 中的参数传递类型有两种：按值传递和按引用传递。 Go 默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符 \u0026，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。 函数调用时，切片（slice）、映射（map）、接口（interface）、通道（channel）这些引用类型默认使用按引用传递。几乎在任何情况下，按引用传递的消耗都比按值传递小。按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用 return 返回。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3.2 命名参数 函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如 func f(int, int, float64)，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下： package main import \"fmt\" var num int = 10 var numx2, numx3 int func main() { numx2, numx3 = getX2AndX3(num) PrintValues() numx2, numx3 = getX2AndX3_2(num) PrintValues() } func PrintValues() { fmt.Printf(\"num = %d, 2x num = %d, 3x num = %d\\n\", num, numx2, numx3) } func getX2AndX3(input int) (int, int) { return 2 * input, 3 * input } func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3 return } // Output: // num = 10, 2x num = 20, 3x num = 30 // num = 10, 2x num = 20, 3x num = 30 命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的 return 语句（带参数也不会出错）。 当需要返回多个非命名返回值时，需要使用括号包围，如(int, int)，但对命名返回值，即使只有一个返回值，也要用括号包围。 Tips 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3.3 空白符 空白符_用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:3","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3.4 变长参数 如果函数最后一个参数是...type的形式，那么函数就可以处理一个变长的参数，这个长度可以是 0，这样的函数称为变参函数： func myFunc(a, b, arg ...int) {} 变长参数的本质是一个切片，如下例： func Greeting(prefix string, who ...string) // 函数定义 Greeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\") // 调用 变量who的值为 []string{\"Joe\", \"Anna\", \"Eileen\"}。 如果参数本身就存在一个切片类型中，比如切片 slice1，则可以通过 slice1... 的形式传递参数，之前的切片部分使用 append 函数时已经这样使用过。 package main import \"fmt\" func main() { x := min(1, 3, 2, 0) fmt.Printf(\"The minimum is: %d\\n\", x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf(\"The minimum in the slice is: %d\", x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v \u003c min { min = v } } return min } // Output: // The minimum is: 0 // The minimum in the slice is: 1 一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递： func F1(s ...string) { F2(s...) F3(s) } func F2(s ...string) { } func F3(s []string) { } 变长参数可以作为对应类型的 slice 进行二次传递。 注意 但是如果变长参数的类型并不是都相同的呢？有 2 种方案可以解决这个问题； 使用结构体 使用空接口 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:4","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"3.5 函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要这个被调用函数的返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子： package main import ( \"fmt\" ) func main() { callback(1, Add) } func Add(a, b int) { fmt.Printf(\"The sum of %d and %d is: %d\\n\", a, b, a+b) } func callback(y int, f func(int, int)) { f(y, 2) // this becomes Add(1, 2) } // Output: // The sum of 1 and 2 is: 3 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:3:5","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"4. 内置函数 Go 语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如 len(), cap(), append()，以下是内置函数列表： 名称 说明 close() 用于管道通信。 len()、cap() len() 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap() 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 map()）。 new()、make() new() 和 make() 均是用于分配内存：new() 用于值类型和用户定义的类型，如自定义结构，make() 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new() 进行更多的工作。 copy()、append() 用于复制和连接切片。 panic()、recover() 两者均用于错误处理机制。 print()、println() 底层打印函数，在部署环境中建议使用 fmt 包。 complex()、real()、 imag() 用于创建和操作复数。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"5. 匿名函数与闭包 匿名函数是类似 func(x, y int) int { return x + y } 这样没有名字的函数。这样的函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：fplus := func(x, y int) int { return x + y }，然后通过变量名对函数进行调用：fplus(3,4)。当然，匿名函数也可以被直接调用，例如：func(x, y int) int { return x + y } (3, 4)。 下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用： func() { sum := 0 for i := 1; i \u003c= 1e6; i++ { sum += i } }() 另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中： func(u string) { fmt.Println(u) … }(v) 还应该知道的，匿名函数可以被赋值给某个变量，如fplus := func(x, y int) int { return x + y }，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：fplus(3, 4)。 所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子： func f(i int) func() int { return func() int { i++ return i } } 在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子： package main import \"fmt\" func main() { var f = Adder() fmt.Print(f(1), \" - \") fmt.Print(f(20), \" - \") fmt.Print(f(300)) } func Adder() func(int) int { var x int return func(delta int) int { x += delta return x } } // Output: // 1 - 21 - 321 从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。 在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的： var g int go func(i int) { s := 0 for j := 0; j \u003c i; j++ { s += j } g = s }(1000) // Passes argument 1000 to the function literal. 这样闭包函数就能够被应用到整个集合的元素上，并修改它们的值。然后这些变量就可以用于表示或计算全局或平均值。 这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数： func MakeAddSuffix(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } 现在可以生成如下函数： addBmp := MakeAddSuffix(\".bmp\") addJpeg := MakeAddSuffix(\".jpeg\") 然后调用它们： addBmp(\"file\") // returns: file.bmp addJpeg(\"file\") // returns: file.jpeg ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:5:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"6. defer和追踪 关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种： 包含 defer 语句的函数返回前 包含 defer 语句的函数执行到末尾 所在的 goroutine 发生 panic 时 一个例子如下： func main() { defer fmt.Println(\"Fourth\") fmt.Println(\"First\") fmt.Println(\"Third\") } // Output: // First // Third // Fourth defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例： i := 1 defer fmt.Println(\"Deferred print:\", i) i++ fmt.Println(\"Normal print:\", i) // Output: // Normal print: 2 // Deferred print: 1 不要小看这一点，如果 defer 语句中嵌套了其他的函数，将会出现意料之外的结果，看看下面代码追踪的例子： package main import \"fmt\" // 用于在进入某个函数时打印相关的消息 func trace(s string) string { fmt.Println(\"entering:\", s) return s } // 用于在离开某个函数时打印相关的消息 func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { // 由于 defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，因此它会先执行 trace(\"b\") 来确定函数 un() 中参数的值 defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } // Output: // entering: b // in b // entering: a // in a // leaving: a // leaving: b 但与匿名函数结合起来后，变量的值在函数运行时才会确定： func f1() (r int) { r = 1 defer func() { r++ fmt.Println(r) }() r = 2 return } func main() { f1() } // Output: // 3 上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事 defer 函数执行时机是外层函数设置返回值之后，即将返回之前 return xxx 操作并不是原子的 下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是 1 不是 0： func f1() (r int) { defer func() { r++ }() return 0 } func main() { fmt.Println(f1()) } 来一个更复杂的例子： func double(x int) int { return x + x } func triple(x int) (r int) { defer func() { r += x }() return double(x) } func main() { fmt.Println(triple(3)) } // Output: // 9 上面的例子实际上等价于： func triple(x int) (r int) { r = double(x) func() { r += x }() return } 多个 defer 也可以同时使用时，以逆序执行，即后进先出（类似栈）： func f() { for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } } // Output: // 4 3 2 1 0 defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如 关闭文件流 // open a file defer file.Close() 解锁一个加锁的资源 mu.Lock() defer mu.Unlock() 打印最终报告 printHeader() defer printFooter() 关闭数据库链接 // open a database connection defer disconnectFromDB() ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:6:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"7. 编写规范 Go 是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是 Uber 开源在 github 的编码规范，有两条主要规则 函数应按粗略的调用顺序排序 同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于newXYZ()这样的新建某个类型的函数。一个简单的例子如下 type something struct{ ... } func newSomething() *something { return \u0026something{} } func (s *something) Cost() { return calcCost(s.weights) } func calcCost(n []int) int {...} func main(){ ... } 最后，main 函数放在所有函数的最后。 ","date":"2023-02-12","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/:7:0","tags":["Golang语法基础"],"title":"Golang语法基础6-函数","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E5%87%BD%E6%95%B0/"},{"categories":["编程技术"],"content":"只有基本的数据类型无法适应所有的情况，当需要存储和处理大量数据时，通常会使用数组、映射、链表等数据结构，称之为容器(container)。在 Go 语言中，由于数组不够灵活，增加了切片(slice)类型，切片也是一种容器。 C 语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。 本篇只介绍数组和切片和映射类型。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"1. 数组 数组是有限个相同类型的数据的集合，Go 语言中数组声明的格式为： var identifier [len]type 数组元素可以是任意基本类型，数组本身、结构体、接口（空）等，当元素类型是数组本身时，即为二维或多维数组。 应注意，数组长度也是数组类型的一部分，[5]int和[10]int是两个不同类型。 数组元素通过索引来读取或修改，不同于字符串，数组是可变的。索引的范围从0到len(arr)-1，内置函数len()可用来获取数组长度，数组长度最大为 2GB。 声明数组时所有的元素都会被自动初始化为元素类型的零值，初始化的过程是按照数组元素的顺序进行的。 当数组元素较少时，可以在声明时直接进行初始化，一些表达方式如下： var arr1 = [3]int{1, 2, 3} var arr2 = [10]int{1, 2, 3} // 剩下的元素会自动补全，其值为0 var arr3 = [3]string{2:\"test\"} // 只有索引2被赋予了实际的值，其它元素都初始化为空字符串 数组长度的位置也可以使用省略号，此时数组长度会根据提供的值的个数自动推断： arr := [...]int{1, 2, 3} fmt.Println(len(arr)) // 3 数组元素较多时使用for循环初始化： var arr [100]int // 使用for循环初始化 for i := 0; i \u003c len(arr); i++ { arr[i] = i * 2 } Go 语言中数组是一种值类型，而不像 C 语言是指向首元素的指针，因此可以使用内置函数new()来创建数组（new()用来创建值类型，返回所创建类型的指针）： var arr1 = new([5]int) 这种方式和var arr2 [5]int的区别是，arr1 的类型是*[5]int，而 arr2 的类型是[5]int，一个简单的式子可以帮助理解： arr2 := *arr1 当像上式这样进行赋值时，我们把 arr1 的值做了一次拷贝，因此修改 arr2 不会对 arr1 产生影响。同理，函数中数组作为参数传入时，传入值类型的数组不会改变原值，但是当数组很大时，直接传入数组作为参数会消耗很多内存，可以传入数组的指针或使用切片来解决。以下是传入指针的例子： package main import \"fmt\" func f(a [3]int) { fmt.Println(a) } func fp(a *[3]int) { fmt.Println(a) } func main() { var ar = [3]int{1, 2, 3} f(ar) // passes a copy of ar fp(\u0026ar) // passes a pointer to ar } 数组可以组装成多维数组，一个二维数组可以理解为一个数组类型的数组，以下演示一个二维数组的声明： // 声明一个二维整型数组，两个维度的长度分别是 4 和 2 var array [4][2]int // 声明并初始化数组中索引为 1 和 3 的元素 array = [4][2]int{1: {20, 21}, 3: {40, 41}} // 声明并初始化数组中指定的元素 array = [4][2]int{1: {0: 20}, 3: {1: 41}} 注意 var n int = 5 var arr1 = new([n]int) // 错误 var arr2 = [n]int // 错误 这样的语句无法通过编译，因为数组的长度只能由常量来定义。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"2. 切片 切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型。可以理解为动态数组。 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中切片比数组更常用。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"2.1 声明与使用 切片声明的格式如下，基本就是去掉了数组声明中的长度： var identifier []type 未初始化的切片默认为 nil，长度为 0。切片的初始化格式为： var slice []type = arr[start:end] 表示 slice 是数组 arr 从 start 索引到 end-1 索引之间的元素构成的子集，切片的大小可以和数组相等，但应注意到终止索引的项并不包含在切片内。一些切片的方式如下： var arr = [5]int{1,2,3,4,5} s := arr[:] s := arr[0:5] // 这两个切片都等于整个数组 s := arr[:3] s := arr[0:3] // 这两式输出都是[1,2,3] s := arr[2:] s := arr[2:5] // 这两式输出都是[3,4,5] 切片是可索引的，但切片的索引与原数组的索引不一定相同，如上例最后一行，s[0] = arr[2]。 切片的长度在运行时可修改，最小为 0 最大为相关数组的长度，具体的长度值可通过len()函数获得。 cap()函数可以计算切片的容量，也就是切片最长可以达到多少。举个例子，如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量。 arr := [5]int{1, 2, 3, 4, 5} s := arr[2:4] // len(s)为2，cap(s)为3 容量之所以从 s[0] 开始计数，是因为切片只能向后移动，任何试图获取切片第一个元素之前的数组元素的做法都会导致编译错误。例如，如果 s2 是一个切片，你可以将 s2 向后移动一位 s2 = s2[1:]，但是末尾没有移动（有点像滑动窗口）。由于切片只能向后移动，s2 = s2[-1:] 会导致编译错误。 两个直接创建切片的例子如下： s := [3]int{1,2,3}[:] // 本质上等于 s := [3]int{1,2,3} 然后 s[:] x := []int{2,3,4,5,6} 但本质上这两者都是先创建的数组，然后取了与数组等长的切片。 注：切片本身已是引用，它没有指针，因此不要对它使用取地址符。 在上面的数组部分我们谈到当数组很大时，直接将数组作为参数传给函数会占用大量内存，因此我们介绍了如何传入数组的指针，这里我们再介绍如何传入切片：我们应当在函数中声明参数为切片类型，调用函数时，把数组分片，创建一个切片引用传递给该函数，示例如下： func sum(a []int) int { s := 0 for i := 0; i \u003c len(a); i++ { s += a[i] } return s } func main() { var arr = [5]int{0, 1, 2, 3, 4} sum(arr[:]) } 数组作为值类型使用new()来创建，而切片作为引用类型，需要使用make()。 var slice []type = make([]type, len) slice := make([]type, len) // 简写形式 其中第二个参数 len 是数组的长度，也是 slice 的初始长度，例如定义s1 := make([]int, 10)，那么cap(s1) == len(s1) == 10。 也可以在声明时利用第三个参数指定切片容量： slice := make([]type, len, cap) 因此，下面两种方法可生成相同切片： make([]int, 50, 100) new([100]int)[0:50] 字符串可以看作是一个不可变的字节数组，因此也可以切分为切片使用。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:1","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"2.2 常用操作 由于切片的灵活性，会经常使用切片进行一些操作，这里简单介绍几种。 重组 使用 make 创建切片的时候可以指定容量，因此必要时可以改变切片长度直到达到容量上限，改变切片长度的过程称为切片重组（reslice），如将切片扩展1位： s = s[0:len(s)+1] // len(s)+1 \u003c= cap(s) 复制 增加切片的容量必须创建一个新的更大的切片并把原分片的内容都拷贝过来。切片拷贝使用 copy() 函数，函数原型如下： copy(destSlice, srcSlice []T) int 作用是将 srcSlice 复制到 destSlice，两者类型必须一致，返回值为实际复制的元素个数。源地址和目标地址可能会有重叠。复制的元素个数是 srcSlice 和 dstSlice 的长度最小值。示例如下： sl_from := []int{1, 2, 3} sl_to1 := make([]int, 5) sl_to2 := make([]int, 2) n1 := copy(sl_to1, sl_from) // n1 = 3, s1_to1 = [1,2,3,0,0] n2 := copy(sl_to2, sl_from) // n2 = 2, s1_to2 = [1,2] 追加 追加也是一种切片扩容的方式，主要使用append()函数，函数原型是： func append(s []T, x ...T) []T 作用是将 0 个或多个具有相同类型 T 的元素追加到切片 s 后面并返回新的切片，追加的元素类型需要和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。 sl3 := []int{1, 2, 3} sl3 = append(sl3, 4, 5, 6) // sl2 = [1,2,3,4,5,6] // 若你想将切片 sl4 追加到 sl3 后面，只要使用扩展运算符...将第二个参数扩展成一个列表即可 sl4 := []int{4, 5, 6} sl3 = append(sl3, sl4...) // sl3 = [1,2,3,4,5,6] append() 在大多数情况下很好用，但是如果你想完全掌控整个追加过程，你可以实现一个这样的 AppendByte() 方法： func AppendByte(slice []byte, data ...byte) []byte { m := len(slice) n := m + len(data) if n \u003e cap(slice) { // if necessary, reallocate // allocate double what's needed, for future growth. newSlice := make([]byte, (n+1)*2) copy(newSlice, slice) slice = newSlice } slice = slice[0:n] copy(slice[m:n], data) return slice } func copy(to, from []T) int 方法将类型为 T 的切片从源地址 from 拷贝到目标地址 to，覆盖 to 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 from 和 to 的长度最小值。 删除 删除切片元素没有专用语法，需要使用切片本身的特性。分为三种情况：从开始位置删除，从中间位置删除，从末尾删除。 从开始位置删除 直接移动数据指针： a = []int{1, 2, 3} a = a[1:] // 删除开头1个元素 a = a[N:] // 删除开头N个元素 不移动数据指针，而是将后面的数据向开头移动： a = []int{1, 2, 3} a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 使用copy()函数： a = []int{1, 2, 3} a = a[:copy(a, a[1:])] // 删除开头1个元素 a = a[:copy(a, a[N:])] // 删除开头N个元素 从中间位置删除 对剩余的元素做一次整体移动，可以使用copy()或append()： a = []int{1, 2, 3, 4, ...} a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素 从末尾删除 a = []int{1, 2, 3} a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 删除开头和末尾都是删除中间的特殊情况。 插入 插入的一般方式是使用两次 append() 函数： a = append(a[:i], append([]T{x}, a[i:]...)...) // 在索引i的位置插入元素x a = append(a[:i], append(make([]T, j), a[i:]...)...) // 在索引i的位置插入长度为j的新切片 a = append(a[:i], append(b, a[i:]...)...) // 在索引i的位置插入切片b的所有元素 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:2","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"2.3 搜索及排序 标准库提供了 sort 包来实现常见的搜索和排序操作。您可以使用 sort 包中的函数 func Ints(a []int) 来实现对 int 类型的切片排序。例如 sort.Ints(arri)，其中变量 arri 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可以通过函数 IntsAreSorted(a []int) bool 来检查，如果返回 true 则表示已经被排序。 类似的，可以使用函数 func Float64s(a []float64) 来排序 float64 的元素，或使用函数 func Strings(a []string) 排序字符串元素。 想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，您就可以使用函数 func SearchInts(a []int, n int) int 进行搜索，并返回对应结果的索引值。 当然，还可以搜索 float64 和字符串： func SearchFloat64s(a []float64, x float64) int func SearchStrings(a []string, x string) int 您可以通过查看 官方文档 来获取更详细的信息。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:3","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"2.4 对切片的理解 切片在内存中如何表示？ 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。下图给出了切片在内存中如何表示： 我们可以看到，切片 x 和切片 y 是关于同一个数组的引用，该数组也就是所谓的相关数组。切片 x 在声明时，该相关数组便被创建，并把这个相关数组的地址存入切片 x 的指针域，并初始化切片的长度和容量。切片 y 在声明时，由于是对切片 x 的引用，因此它们的指针域指向的是同一个相关数组，只是切片的长度和容量有所不同，也就是说，它们的数据是共享的。由于切片 y 是从下标为 1 的地方开始引用，因此它的容积最大为4。 切片的变量名后是指针还是结构体实例？ 这要看具体情况具体分析，切片有两种特殊的状态容易混淆：nil切片和空切片。 nil 切片是由 var 关键字声明，但未分配内存空间的切片，它的长度和容量都为0。 空切片是由 make([]T, 0) 语句声明，分配了内存空间，但是相关数组的长度为0，因此它的长度和容积也都为0。 总的来说，除了 nil 切片是空指针外，其余的切片均是实例。因此当 x = y 这样的操作执行后，y 实际上是将自己的结构体复制了一份赋值给了 x。 new() 和 make() 的区别是什么？ 看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。 new(T) 返回一个地址，该地址指向了一个类型为T，初始化为零值的内存空间。适用于数组和结构体。 make(T) 返回一个实例。该实例为T类型的初始值。它适用于 3 种内建的引用类型：切片（slice）、映射（map）、管道（channel）。 简单来说，new() 函数分配内存，make() 函数初始化。下图给出了它们的区别： 我们可以看到，用 new 创建的切片返回的是一个地址，该地址指向了切片的结构体，不过结构体内的指针域为空值（零值）。而用 make 创建的切片返回的是一个切片的实例，它的指针域指向了一个长度为 0 的相关数组。 如何理解 new、make、slice、map、channel 的关系 slice、map 以及 channel 都是 golang 内建的一种引用类型，三者在内存中存在多个组成部分， 需要对内存组成部分初始化后才能使用，而 make 就是对三者进行初始化的一种操作方式。 new 获取的是存储指定变量内存地址的一个变量，对于变量内部结构并不会执行相应的初始化操作， 所以 slice、map、channel 需要 make 进行初始化并获取对应的内存地址，而非 new 简单的获取内存地址。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:4","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"3. 映射 映射 (map) 其实就是数据结构里的哈希表，但不少语言都已经把它作为了内置的数据类型。映射是元素对的无序集合，由键 (key) 和值 (value) 两部分构成，可以通过键快速查找值（比线性查找快，但实际上比通过数组或切片索引直接读取要慢）。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"3.1 声明与初始化 Golang 中的 map 是引用类型，声明方法如下： // 语法格式 var mapname map[keytype]valuetype // 示例 var map1 map[string]int 凡是可以用 == 或 != 操作符比较的类型都可以作为键的类型，比如 string、int、float、只包含基本类型的结构体、指针和接口，而数组、切片以及含有数组切片的结构体无法作为键类型。值的类型是任意的，当值类型是一些复杂结构时，往往有比较特殊的用途，比如 函数。值类型为函数时可以视作分支结构，key 用来选择要执行的函数。 空接口。我们可以用空接口作为值类型存储任意类型的值，只是在使用前需要做一次类型断言。 切片。通过将值类型定义为切片类型，应对一个Key对应多个值的情况，示例如下： mp1 := make(map[int][]int) map 可以动态增长，声明时不关心长度，使用时其长度使用内置函数len()获取。 未初始化的 map 值为 nil，如果此时试图给 map 添加元素会导致运行时错误，因此添加元素必须首先初始化。map 初始化的方法有两种 直接使用大括号，在数组与切片的初始化中已经见过这种方法，示例如下： var mapLit map[string]int mapLit = map[string]int{\"one\":1, \"two\":2} 使用 make，map 是引用类型，因此使用 make 初始化。以 make 方式初始化其实相当于mapLit := map[string]int{}： mapLit := make(map[string]int) 虽然 map 可以动态增长，没有长度限制，但是也可以在一开始标明其初始容量： mapLit := make(map[string]int, 100) 当 map 增长到容量上限后，继续增加新的键值对，map 的大小会自动加1，因此容量对 map 并没有多大影响。但出于性能考虑，对于很大的 map 或需要急速扩张的 map，即使是只知道大概的容量，也建议提前声明。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"3.2 访问与删除map中的元素 如果 key1 是 map1 的 key，那么 map1[key1] 就是对应 key1 的值，map 中就通过这种类似数组索引的方式访问元素： val1 := map1[key1] 上式将 key1 对应的值赋给了 val1，但反过来，也可以通过这种形式设置对应 key1 的值，如下： map1[key1] = val1 访问 map 中不存在的 key 会获得它所对应的值类型的空值，因此我们还需要有一种办法来判断键值对是否存在，这样才能区分到底是键值对本身不存在，还是值是空值。实际上通过键来访问值会返回两个结果，如下： val1, ok := map1[key1] 当键值对存在时，ok 的值为 true，而当键值对不存在时，ok 的值为 false。如果只想判断某个键值对是否存在，可以将返回的真正的值设置为匿名变量： _, ok := map1[key1] map 中元素的删除使用内置函数delete()，格式如下： delete(mapname, keyname) 如果键值对不存在，删除操作也不会产生错误： mapLit := map[string]int{\"one\": 1, \"two\": 2} delete(mapLit, \"one\") 但 Golang 并没有提供清空 map 中所有元素的方法，清空 map 的唯一办法就是重新 make 一个新的 map： mapLit := map[string]int{\"one\": 1, \"two\": 2} mapLit = make(map[string]int) ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"3.3 遍历map for-range 可用于遍历 map： for key, value := range map1 { ... } 其中第一个返回值 key 是 map 中的 key 值，第二个返回值 value 则是 key 对应的 value 值。如果只关心值，可以省略键： for _, value := range map1 { ... } 而如果只关心键，则可以省略值： for key := range map1 { fmt.Printf(\"key is: %d\\n\", key) } 还需要知道的一点是，for-range 结构虽然能遍历整个 map，但我们并不知道 map 中键值对排列的顺序，并不是按 key 的顺序排列的，也不是按 value 的顺序排列。 如果想要为 map 排序，那么就需要先通过遍历将 map 的所有数据复制到切片中，再对切片排序，最后打印出来 // the telephone alphabet: package main import ( \"fmt\" \"sort\" ) var barVal = map[string]int{\"alpha\": 34, \"bravo\": 56, \"charlie\": 23} func main() { fmt.Println(\"unsorted:\") for k, v := range barVal { fmt.Printf(\"Key: %v, Value: %v ; \", k, v) } keys := make([]string, len(barVal)) i := 0 for k := range barVal { keys[i] = k i++ } sort.Strings(keys) fmt.Println() fmt.Println(\"sorted:\") for _, k := range keys { fmt.Printf(\"Key: %v, Value: %v ; \", k, barVal[k]) } } // Output: // unsorted: // Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; // sorted: // Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; 上例按 key 进行了排序并输出，如果想要更好的显示，可以使用结构体切片： type name struct { key string value int } ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:3","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"3.4 map类型的切片 map 类型的切片是一个很有意思的结构，构造它需要使用两次make()函数，第一次分配切片，第二次分配切片中的每个 map 元素： package main import \"fmt\" func main() { // Version A: items := make([]map[int]int, 5) for i:= range items { items[i] = make(map[int]int, 1) items[i][1] = 2 } fmt.Printf(\"Version A: Value of items: %v\\n\", items) // Version B: NOT GOOD! items2 := make([]map[int]int, 5) for _, item := range items2 { item = make(map[int]int, 1) // item is only a copy of the slice element. item[1] = 2 // This 'item' will be lost on the next iteration. } fmt.Printf(\"Version B: Value of items: %v\\n\", items2) } // Output: // Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]] // Version B: Value of items: [map[] map[] map[] map[] map[]] 应该意识到，for-range 结构中，value 只是值的拷贝，对它做操作不会影响原值，因此上例中第二种写法是错误的，真正的 map 元素并没有得到初始化。 ","date":"2023-02-11","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:4","tags":["Golang语法基础"],"title":"Golang语法基础5-数组、切片与映射","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的运算符和流程控制。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"1. 运算符 Go 语言的运算符有 6 种，如下表所示： 运算符类型 运算符 算术运算符 +，-，*，/，%，++，– 关系运算符 ==，!=，\u003e，\u003c，\u003e=，\u003c= 逻辑运算符 \u0026\u0026，||，! 位运算符 \u0026，|，^，«，»，\u0026^ 赋值运算符 =，+=，-=，*=，/=，%=，«=，»=，\u0026=，^=，!= 其它运算符 \u0026，* 基本的运算规则都与 C 语言相同，一些注意事项列举如下： 算术运算符中自增自减运算符只能作为语句使用，不能用于表达式： a++ // 允许 a-- // 允许 a = a++ //不允许，编译错误 a[i] = b[i++] //不允许，编译错误 整数除以 0 会导致编译错误，如果编译时未检出会导致程序崩溃。浮点数除以 0.0 会返回无穷大，用+Inf表示。 逻辑运算符具有短路效果，即当逻辑运算符左边表达式的值已经能够决定整个表达式的值的时候逻辑运算符右边的表达式将不会被执行。 位运算符是对整数在内存中的二进制位进行操作的，它只能用于整数类型的变量，且需它们拥有等长位模式。 假定 A = 60，B = 13，则 A = 0011 1100 B = 0000 1101 A \u0026 B = 0000 1100 // 结果为12 A | B = 0011 1101 // 结果为61 A ^ B = 0011 0001 // 结果为49 A \u003c\u003c 2 = 1111 0000 // 结果为240 A \u003e\u003e 2 = 0000 1111 // 结果为15 其它运算符中的\u0026是取地址符，*是指针变量。 运算符的优先级是不同的，下表从上往下代表优先级从高到低： 优先级 运算符 7 ^ ! 6 * / % « » \u0026 \u0026^ 5 + - | ^ 4 == != \u003c \u003c= \u003e \u003e= 3 \u003c- 2 \u0026\u0026 1 || 二元运算符的运算方向均是从左到右，必要时可以使用括号提升优先级或更清楚地表达。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2. 控制结构 除去顺序结构外，Go 语言提供的基本流程控制结构包括 条件结构 if-else 结构 switch 结构 select 结构，用于 channel 的选择（协程与通道部分） 循环结构 for for-range 同时，Go 还提供了关键字break、continue和goto用来辅助进行流程控制，以及return语句提前结束执行。 注意 在这些结构中，Go 都省略了条件语句两侧的小括号，使视觉上更加简洁。 除case关键字后的语句，即使代码块只有一行，大括号也不可省略 左大括号必须和关键字在同一行，对多分支结构中的else关键字，右大括号也要和它在一行。这两条规则是编译器的强制规定。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.1 if-else 结构 if-else 结构的基本形态与C语言相同。可以省略else关键字变成单分支结构，也可以添加else if变成多分支，但为了代码简洁，过多的分支最好换用 switch 结构实现。 if condition1 { // do something } else { // do something else } 当双分支结构在代码块的末尾时，通常会将 else 中原本的代码块迁移出来放在最后，如： if condition { return true } return false Go 中 if 还可以在条件语句前添加一个初始化语句，以分号分隔： if initialization; condition { // do something } 例如： if val := 10; val \u003e max { // do something } 但需要注意的时，使用简短方式 := 声明和初始化的变量作用域只限于 if 结构的代码块内，属于局部变量。 由于 Go 语言并行赋值的特性，if 语句经常用于测试多返回值函数的错误。返回某个值以及 true 表示成功，返回零值（或 nil）以及 false 表示失败： if value, ok := readData(); ok { ... } 当不使用 true 或 false 时，也可以使用一个 error 类型的变量来代替作为第二个返回值，成功执行，则 error 的值为 nil；否则执行失败，返回的值会包含相应的错误信息： var err error if err := file.Chmod(0664); err != nil { fmt.Println(err) return err } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.2 switch 结构 switch 结构的基本形态依然同 C 语言相同： switch var1 { case val1: ... case val2: ... default: ... } 不同的是，Go 中 switch 语句接受任意形式的表达式，如上例中 var1 可以是任何类型，而 val1 和 val2 可以是同类型的任意值，不局限于数值。 可以同时测试多个可能符合条件的值，使用逗号分隔，例如case val1, val2, val3 每个case分支都是唯一的，从上到下逐一测试，一旦成功匹配到某个分支，执行完对应的代码块后会自动退出整个 switch 结构，而不需要使用break结束。因此，程序不会自动的去执行剩下的 case 分支的代码，如果想继续执行，需要使用 fallthrough 关键字： switch i { case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用 } 注意 fallthrough 语句执行后，就不会再判断变量 i 是否满足分支，后续所有分支内的代码均会被无条件执行！ case 语句后不需要用大括号包围代码块，default 分支可以出现在任何顺序，但最好放在最后： package main import \"fmt\" func main() { var num1 int = 100 switch num1 { case 98, 99: fmt.Println(\"It's equal to 98\") case 100: fmt.Println(\"It's equal to 100\") default: fmt.Println(\"It's not equal to 98 or 100\") } } //Output: //It's equal to 100 switch 可以不提供条件语句，然后在每个 case 分支测试不同条件，可以替换分支比较多的if-else结构，简化代码： switch { case i \u003c 0: f1() case i == 0: f2() case i \u003e 0: f3() default: ... } switch的条件语句还可以是初始化语句： switch a, b := x[i], y[j] { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:2","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.3 for 结构 Go 中只有 for 用于循环结构，没有 C 中的 while 或 do while，基本形态如下： for 初始化语句; 条件语句; 修饰语句 { ... } 同样，for 关键字后的三个语句不需要小括号，左大括号需和关键字在同一行： 可以只保留条件语句，这种情况下可以去掉所有分号，大致等同于其它语言的 while 循环： package main import \"fmt\" func main() { var i int = 5 for i \u003e= 0 { i = i - 1 fmt.Printf(\"The variable i is now: %d\\n\", i) } } 或者省略条件语句，但必须在循环体中存在条件判断以确保在某个时候退出循环，退出可以使用break或return： for i := 0; ; i++ { ... } 或者三条语句全部省略，但同样需要在循环体中添加退出条件： for { ... } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:3","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.4 for-ranges 结构 这是 Go 中特有的迭代结构，可以迭代数组、切片、map、字符串等任意一个集合，一般形式为： for k, v := range set { ... } k 为索引，每次递增，v 为索引对应的值的拷贝。值得注意的是，由于 v 只是值的拷贝，任何对它的修改都不会影响集合中原来的值，除非索引是指针。 如果不需要索引，可以使用匿名变量_忽略它： for _, v := range set { ... } 但如果只需要索引而不需要值，可以直接省略不写： for k := range set { ... } // Output: 0 1 2 ... 字符串通过 for-range 结构获取的元素是 rune 类型。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:4","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"3. 辅助语句 控制结构中，常用的辅助语句有：break、continue、goto、return。 break 用来跳出循环，在 for 循环中跳出一层循环，在 switch 或 select 语句中，跳过整段代码块： for i:=0; i\u003c3; i++ { for j:=0; j\u003c10; j++ { if j\u003e5 { break } print(j) } print(\" \") } // Output: // 012345 012345 012345 continue 用来忽略剩余的循环体直接进入下一次循环，只存在于for循环中： for i := 0; i \u003c 10; i++ { if i == 5 { continue } print(i) print(\" \") } // Output: // 0 1 2 3 4 6 7 8 9 for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词，下例中 continue 语句指向 LABEL1，当执行到该语句时，就会跳转到 LABEL1 标签的位置起继续执行，不过此时注意循环体内的变量并不会被释放，当 j==4 循环跳出后，i 会自动变成下一个循环的值，不会陷入无限循环。 package main import \"fmt\" func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } 标签的名称和一般的标识符相同，都是大小写敏感的，但为了可读性，一般全部使用大写字母。同变量相同，标签定义未使用也会导致编译错误。 goto 关键字是配合标签使用的，但这种用法并不被推荐，因为很可能导致糟糕的代码结构，一如当年的 PASCAL。 逆序的标签虽然可能导致错误，但正序的标签（标签位于 goto 语句之后）则可以正常使用，但标签和 goto 之间不能有新定义变量的语句，否则会导致编译失败。 // compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8 package main import \"fmt\" func main() { a := 1 goto TARGET // compile error b := 9 TARGET: b += a fmt.Printf(\"a is %v *** b is %v\", a, b) } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的常量、变量、基本数据类型和常用的类型转换。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"1. 常量 常量用于存储程序运行过程中恒定不变的数据，因此我们无法在程序运行过程中修改它的值，如果你在代码中试图修改常量的值则会引发编译错误。Go语言中使用关键字 const 定义常量，格式如下： const identifier [type] = value 常量的值必须在编译时能够确定，因此只能是基本数据类型和表达式。一个常量定义的例子如下： const Pi float64 = 3.1415926 存储在常量中的数据类型只可以是：布尔型、数字型（整数型、浮点型和复数）和字符串型。 另外，由于 Go 的特性，常量的定义具有一些不同的形式： 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 const Pi 3.1415926 Go 支持在同一行同时定义多个值，称为并行赋值。 const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday = 1, 2, 3, 4, 5, 6, 7 Go 支持批量声明，这种定义形式叫做因式分解关键字。 const ( Monday, Tuesday, Wednesday = 1, 2, 3 Thursday, Friday, Saturday = 4, 5, 6 Sunday = 7 ) 未定义类型的常量会在必要时刻根据上下文来获得相关类型。例如： var n int f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。 正确的做法：const c1 = 2 / 3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出： const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 const Log2E = 1 / Ln2 // this is a precise reciprocal const Billion = 1e9 // float constant const hardEight = (1 \u003c\u003c 100) \u003e\u003e 97 根据上面的例子我们可以看到，反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。 此外，Go 还提供关键字 iota，用作常量计数器，只能在常量定义时使用。iota 在 const 关键字出现时被重置为 0，每新增一行常量声明新增一个计数，能极大的简化定义。一个例子如下： const a = iota // a = 0 const ( b = iota // b = 0 c = iota // c = 1 ) 可以使用空白标识符跳过不想要的值： const ( a = iota // a = 0 _ = iota // _ = 1 空白标识符可以简单地理解为一个“只写”的变量 c = iota // c = 2 ) 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式： const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) 同一行有多个常量不产生影响，中间有数值插队也不产生影响，因为 iota 的值是每新增一行声明增加 1： // 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次 const ( Apple, Banana = iota + 1, iota + 2 // Apple = 1 Banana = 2 Cherimoya, Durian // Cherimoya = 2 Durian = 3 Elderberry, Fig // Elderberry = 3, Fig = 4 ) iota 也可以用在表达式中参与运算操作，如： // 使用 iota 结合位运算表示资源状态 const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) // 使用 iota 结合乘法运算表示单位 const ( _ = iota // 使用 _ 忽略不需要的 iota KB = 1 \u003c\u003c (10 * iota) // 1 \u003c\u003c (10*1) MB // 1 \u003c\u003c (10*2) GB // 1 \u003c\u003c (10*3) TB // 1 \u003c\u003c (10*4) PB // 1 \u003c\u003c (10*5) EB // 1 \u003c\u003c (10*6) ZB // 1 \u003c\u003c (10*7) YB // 1 \u003c\u003c (10*8) ) iota小结 只能在定义常量时使用 遇到const关键字重置为0 每次换行声明，iota的值就会增加1 关于 iota 的使用涉及到非常复杂多样的情况，这里解释的并不清晰，因为很难对 iota 的用法进行直观的文字描述。如希望进一步了解，请观看视频教程 《Go编程基础》 第四课：常量与运算符。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"2. 变量 声明变量的一般形式是使用 var 关键字 var identifier type 当一个变量被声明后，系统会自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。 也可以在声明的同时初始化： var a int = 15 最后，由于常量部分提到的三个 Go 的特性，变量的声明和使用也有一些不同的形式： 类型推断，从而可以省略类型定义 var a = 15 并行赋值 var a, b, c = 5, 6, 7 因式分解关键字（一般用于声明全局变量） var ( a = 15 b = false str = \"Go says hello to the world!\" numShips = 50 city string ) 上面提到的所有方式可以用于全局变量，也可以用于局部变量，但还有一种更加简短的声明与定义方式，仅能用于局部变量（函数体内，包括 main 函数），这是我们使用非常多的一种写法： a := 15 这里详细介绍一下常量部分提到过的空白标识符，空白标识符指的是下划线 _，也叫做匿名变量，只允许写入，任何类型都可以赋值给它，但无法使用它的值。我们在使用 iota 关键字时可以使用空白标识符跳过不想要的值，另外一种常见的使用场景是在多重赋值中抛弃不需要的变量。 _, b = 15, 7 匿名变量不会被分配内存，因此不占用内存空间，多次声明也不会引起冲突。 Go 还提供了一种非常友好的功能，如果想要交换两个变量的值，可以直接使用 a, b = b, a 这种形式，不需要再使用临时变量，为程序编写带来了极大的便利。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（可见性规则）。 变量作用域的规则同 C 语言相同，关于值类型和引用类型的理解也和 C 语言相同。 Go 中值类型包括int、float、bool、string、数组、结构体（struct），引用类型包括指针、切片（slices）、映射（maps）和通道（channel）。值类型存储在栈中，引用类型存储在堆中，以便进行垃圾回收。 注意 := 是声明语句。如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： func main() { var a string = \"abc\" fmt.Println(\"hello, world\") } 尝试编译这段代码将得到错误 a declared and not used。 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 fmt.Println(\"hello, world\", a) 会移除错误。 全局变量允许被声明但是不使用。 为什么将变量的类型放在变量的名称之后？ 首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。 而在 Go 中，则可以很轻松地将它们都声明为指针类型：var a, b *int 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3. 基本数据类型 Go 拥有 4 大类共7种基本数据类型 布尔类型 bool 数字类型： 整型 int，根据位数的不同包括 int8, int16, int32, int64 四种以及相对应的 uint 浮点型 float，包括 float32 和 float64 两种 复数 complex，包括 complex32 和 complex64 两种，复数类型并不常用 字符类型： byte，uint8 的别名，完全等同 rune，int32 是别名，完全等同 字符串类型 string Go 语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较。我们将 Go 中不可比较类型总结如下，除此之外，其它类型都是可比较的： 切片类型 映射类型 函数类型 任何字段为不可比较类型的结构体类型，以及任何元素类型为不可比较类型的数组类型 对于接口而言，情况更加复杂一点，如果值的类型是接口，那么它们必须实现了相同的接口。如果条件不满足，则必须事先进行类型转换才可以比较。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.1 布尔类型 使用bool关键字声明，值只可以是常量 true 或 false。 var b bool = true 两个类型相同的值可以使用关系运算符（==和!=）来获得一个布尔类型的值。布尔类型的值之间也可以使用逻辑运算符（!、\u0026\u0026、||）来产生另一个布尔值，运算规则与其它语言相同。 提示 Go 中的布尔值并不等于数字 1 和 0，因此不能直接进行运算。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.2 数字类型 Go 中数字类型分为三种，整型、浮点型和复数类型，其中位的运算采用补码。 整型 整型提供有符号和无符号两种，每一种又分别提供对应 8、16、32、64bit 大小的四种类型，总计八种，列表如下： 整型 无符号整型 int8（-128 -\u003e 127） uint8（0 -\u003e 255） int16（-32768 -\u003e 32767） uint16（0 -\u003e 65,535） int32（-2,147,483,648 -\u003e 2,147,483,647） uint32（0 -\u003e 4,294,967,295） int64（-9,223,372,036,854,775,808 -\u003e 9,223,372,036,854,775,807） uint64（0 -\u003e 18,446,744,073,709,551,615） 除此之外还提供两种不带位数的类型声明：int 和 uint。这两种类型的大小取决于所运行的平台处理器支持的字长，例如，在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 提示 你可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。 尽管 int 有可能是 32 位，但在需要时 int 和 int32 之间也必须显式进行类型转换。 最后还有一种无符号整型 uintptr，它没有指定具体的 bit 大小但被设定为足够容纳一个指针。uintptr 类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方，一般用于指针计算。 int 型是计算最快的类型，也是最常使用的类型。 提示 你可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。 浮点型 Go 语言中没有 float 类型，没有 double 类型，只有 float32 和 float64。它们的算术规范由 IEEE-754 标准定义，该标准被所有现代的 CPU 支持。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。通常应该优先使用 float64 类型，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 复数类型 Go 语言拥有两种复数类型，分别是 complex64（32 位实数和虚数）和 complex128（64 位实数和虚数）。 var c1 complex64 = 5 + 10i // 5 是实部 10i 是虚部 内置的 complex 函数用于构建复数，内置的 real 和 imag 函数分别返回复数的实部和虚部： var cl complex128 = complex(1, 2) // 1+2i fmt.Println(real(cl)) // \"1\" fmt.Println(imag(cl)) // \"2\" cmath 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.3 字符类型 Go语言的字符有两种： byte 型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。 严格来说，字符并不是 Go 语言的一种类型，字符只是整数的别名，因此其零值也是 0。在声明时应使用单引号括起来。 byte 类型是 uint8 的别名，刚好一个字节，足以表示传统 ASCII 编码的字符。例如：var ch byte = 'A'； rune是int32的别名，四个字节，足以表示最长的 UTF-8 字符。例如：var ch rune = '\\u0041'。 提示 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \\u 或者 \\U。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U 前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:3","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.4 字符串类型 字符串底层约定是字节的一个序列，编码方式建议是 UTF-8，但不是必须遵守，通常是 ASCII。因此取字符串单个字符的类型通常是 byte，只有遇到中文等语言是才是 rune。另外，使用 for-range 结构遍历时字符串的单个字符类型是 rune。 字符串是值类型，且值不可变，即创建一个字符串后无法再次修改它的内容 Go 支持以下 2 种形式的字符串： 解释字符串：该类字符串使用双引号括起来，其中的转义字符将被替换，这些转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U：Unicode 字符 \\\\：反斜杠自身 非解释字符串：该类字符串使用反引号括起来，当使用多行字符串时使用这种形式。 a := `abc def` fmt.Println(a) // Output: abc def string 类型的零值为长度为零的字符串，即空字符串 \"\"。 Go 中的字符串是根据长度限定的，而非特殊字符\\0，其长度可以使用内置函数len()来获取，长度的基本含义是字符串在内存中所占字节的个数，所以下面的例子虽然是两个中文，但长度是6 a := \"中国\" fmt.Println(len(a)) // 6 可以将字符串看作数组而索引其内的单个字符，如第 i 个字节表示为str[i-1]。 注意 获取字符串中某个字节的地址的行为是非法的，例如：\u0026str[i]。 使用拼接符+可以拼接两个字符串，以下是一个多行字符串拼接的例子 str := \"Beginning of the string \" + \"second part of the string\" +必须放在第一行末尾，因为编译器会在行尾自动补全分号。当然，+=一样可用于字符串 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) // 输出 “hello, world!” 在循环中使用+拼接字符串并不是最高效的做法，更好的办法是使用string.join()，或者使用字节缓冲bytes.Buffer。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:4","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.5 类型别名 使用某个类型时可以给它起个别名在程序中使用，用于简化名称或解决名称冲突。 在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 package main import \"fmt\" type TZ int func main() { var a, b TZ = 3, 4 c := a + b fmt.Printf(\"c has the value: %d\", c) // 输出：c has the value: 7 } 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法；TZ 可以自定义一个方法用来输出更加人性化的时区信息。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:5","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4. 类型转换 Go语言中类型转换是可行的，但是不存在隐式类型转换，所有的转换都必须显式说明。类型转换的基本格式为： valueOfTypeB = typeB(valueOfTypeA) 两条转换原则如下： 只有相同底层类型的变量间可以进行相互转换（如 int16 和 int32），不同底层类型的变量相互转换会引发编译错误。 类型转换只有从取值范围小的类型转换到取值范围大的类型才能成功，反过来会发生精度丢失（截断）。 var a, b int16 var c int32 A := int32(a) // 标准转换 B := bool(b) // 类型不匹配，引发编译错误 C := int16(c) // 取值范围变小，精度丢失 浮点型可以转换为整型，转换时会将小数部分去掉，只保留整数部分： a := 12.54 fmt.Println(int(a)) // 输出12 精度丢失可以使用专门的函数保证安全，如 int 型到 int8： func Uint8FromInt(n int) (uint8, error) { if 0 \u003c= n \u0026\u0026 n \u003c= math.MaxUint8 { // conversion is safe return uint8(n), nil } return 0, fmt.Errorf(\"%d is out of the uint8 range\", n) } 其它的类型转换则需要使用一些库函数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.1 bool 与 string Go 语言中 bool 类型值与数字 1 和 0 不等同，因此不能和数字类型相互转换（可以简单的使用 if-else 结构完成这一功能）。但借助 strconv 包，可以和 string 类型转换。 // string -\u003e bool b, err := strconv.ParseBool(\"true\") // bool -\u003e string s := strconv.FormatBool(true) 两个函数的原型如下： // ParseBool返回字符串代表的bool值，接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False作为传入参数，其他参数均返回error func ParseBool(str string) (bool, error) { switch str { case \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\": return true, nil case \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\": return false, nil } return false, syntaxError(\"ParseBool\", str) } // FormatBool returns \"true\" or \"false\" according to the value of b. func FormatBool(b bool) string { if b { return \"true\" } return \"false\" } ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:1","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.2 int / float 与 string 与字符串相关的类型转换都是通过 strconv 包实现的。最常用的是 Atoi(string to int) 和 Itoa(int to string) 函数： i, err := strconv.Atoi(\"-42\") s := strconv.Itoa(-42) 函数原型如下 func Atoi(s string) (int, error) func Itoa(i int) string 字符串-\u003e数字类型 ParseFloat, ParseInt, 和 ParseUint 可以将字符串转化为对应的值： f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-42\", 10, 64) u, err := strconv.ParseUint(\"42\", 10, 64) 浮点型函数原型如下： func ParseFloat(s string, bitSize int) (float64, error) bitSize指定了返回值的类型，当 bitSize=32，返回 float32 类型（结果仍是 float64，但会转换为 float32)；当 bitSize=64，返回 float64 类型。只有这两种情况。 整型函数原型如下： func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (uint64, error) 如果 base 为 0 那么实际上 base 由 string 的前缀指定，0x意味着 base=16，0意味着 base=8，否则 base=10，本质上是进制的前缀。若base等于1，小于0或超过36，返回一个error。 bitSize 仍然指定返回值类型. 其值为 0, 8, 16, 32, 和 64 分别对应 int, int8, int16, int32 和 int64. bitSize 值小于 0 或大于 64 ，返回一个 error。 数字类型-\u003e字符串 FormatFloat, FormatInt, 和 FormatUint 可以将值转换为字符串： s := strconv.FormatFloat(3.1415, 'E', -1, 64) s := strconv.FormatInt(-42, 16) s := strconv.FormatUint(42, 16) 浮点型的函数原型如下： func FormatFloat(f float64, fmt byte, prec, bitSize int) string bitSize 表示 f 的来源类型（32：float32、64：float64），会据此进行舍入。 fmt 表示格式：‘b’ (-ddddp±ddd, 二进制指数), ‘e’ (-d.dddde±dd,十进制指数), ‘E’ (-d.ddddE±dd, 十进制指数), ‘f’ (-ddd.dddd, 没有指数), ‘g’ (指数很大时用‘e’, 否则用 ‘f’ ), ‘G’ (指数很大时用‘E’, 否则用 ‘f’ ). 精度 prec 控制数字的个数 (排除指数)。对’e’, ‘E’, 和 ‘f’ ，表示小数点后的数字位数. 对 ‘g’ 和 ‘G’ 是有效数字位数 (trailing zeros are removed)。prec 等于 -1 时则使用最少数量但又必须的数字来表示 f。 整型的函数原型如下： func FormatInt(i int64, base int) string func FormatUint(i uint64, base int) string 返回 base 指定进制的整数 i 的字符串形式，2 \u003c= base \u003c= 36。使用小写字母 ‘a’ 到 ‘z’ 表示大于10的数字。 忽略可能出现的转换错误，可以给出如下例子： package main import ( \"fmt\" \"strconv\" ) func main() { var orig string = \"666\" var an int var newS string an, _ = strconv.Atoi(orig) fmt.Printf(\"The integer is: %d\\n\", an) an = an + 5 newS = strconv.Itoa(an) fmt.Printf(\"The new string is: %s\\n\", newS) } //输出： The integer is: 666 The new string is: 671 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:2","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.3 []rune 与 string 用 for range 遍历字符串可以返回每个字符，返回的字符类型是 rune。但 []rune 类型也经常需要转换为 string，和单个 rune 类型相似，都可以直接进行显示类型转换，如下： a := []rune{'a', 'b', 'c'} b := 'g' c := string(a) d := string(b) fmt.Println(reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c), reflect.TypeOf(d)) fmt.Println(a, b, c, d) //Output []int32 int32 string string [97 98 99] 103 abc g ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:3","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"5. init函数 变量除了可以在全局声明中初始化，也可以在 init() 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main() 函数高。 每个源文件可以包含多个 init() 函数，同一个源文件中的 init() 函数会按照从上到下的顺序执行，如果一个包有多个源文件包含 init() 函数的话，则官方鼓励但不保证以文件名的顺序调用。初始化总是以单线程并且按照包的依赖关系顺序执行。 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 // init.go package trans import \"math\" var Pi float64 func init() { Pi = 4 * math.Atan(1) //init() function computes Pi } 在它的 init() 函数中计算变量 Pi 的初始值。 下面的代码导入上文所创建包 trans（需要 init.go 目录为 ./trans/init.go ）并且使用到了变量 Pi： package main import ( \"fmt\" \"./trans\" ) var twoPi = 2 * trans.Pi func main() { fmt.Printf(\"2*Pi = %g\\n\", twoPi) // 2*Pi = 6.283185307179586 } init() 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 backend()： func init() { // setup preparations go backend() } ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的基本程序结构和语法。让我们从经典的 HelloWorld 程序开始。 package main import \"fmt\" func main(){ fmt.Println(\"hello, world\") } ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"1. 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。 标准库 在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。 Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。 如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。 Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。 如果 A.go 依赖 B.go，而 B.go 又依赖 C.go： 那么编译顺序是：编译 C.go 然后 B.go、 然后是 A.go. 为了编译 A.go, 编译器读取的是 B.o 而不是 C.o. 这种机制对于编译大型的项目时可以显著地提升编译速度。 每一段代码只会被编译一次 一个 Go 程序是通过 import 关键字将一组包链接在一起。 import \"fmt\" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 \"\" 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。 如果需要多个包，它们可以被分别导入： import ( \"fmt\" \"os\" ) 该方法被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义 当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。 如果包名不是以 . 或 / 开头，如 \"fmt\" 或者 \"container/list\"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。 导入包即等同于包含了这个包的所有的代码对象。 除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。 包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件： 可见性规则 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是它们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。 （大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。 因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。 假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。 因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于它们的包名，例如 pack1.Thing 和 pack2.Thing。 你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：import fm \"fmt\"。下面的代码展示了如何使用包的别名： package main import fm \"fmt\" func main(){ fm.Println(\"hello, world\") } 注意：如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！”。 包的分级声明和初始化 你可以在使用 import 导入包之后定义或声明 0 个或多个常量 (const)、变量 (var) 和类型 (type)，这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用，然后声明一个或多个函数 (func)。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"2. 函数 这是定义一个函数最简单的格式： func functionName() 你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。 main() 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main() 函数，则会引发构建错误 undefined: main.main。main() 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main() 函数添加了参数或者返回类型，将会引发构建错误： func main must have no arguments and no return values results. 在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 main.main()，该函数一旦返回就表示程序已成功执行并立即退出。 函数里的代码（函数体）使用大括号 {} 括起来。 左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示： `build-error: syntax error: unexpected semicolon or newline before {` （这是因为编译器会产生 func main() ; 这样的结果，很明显这是错误的） Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误 右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行： func sum(a, b int) int { return a + b } 对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。 因此符合规范的函数一般写成如下的形式： func functionName(parameter_list) (return_value_list) { ... } 其中： parameter_list 的形式为 (param1 type1, param2 type2, …) return_value_list 的形式为 (ret1 type1, ret2 type2, …) 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。 下面这一行调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \\n： fmt.Println(\"hello, world\") 使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当被调用函数的代码执行到结束符 } 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。 程序正常退出的代码为 0 即 Program exited with code 0；如果程序因为异常而被终止，则会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"3. 注释 package main import \"fmt\" // Package implementing formatted I/O. func main(){ fmt.Printf(\"Καλημέρα κόσμε; or こんにちは 世界\\n\") } 上面这个例子通过打印 Καλημέρα κόσμε; or こんにちは 世界 展示了如何在 Go 中使用国际化字符，以及如何使用注释。 注释不会被编译，但可以通过 godoc 来使用。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可。当开发人员需要了解包的一些情况时，自然会用 godoc 来显示包的文档说明，在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起。另外，在多段注释之间应以空行分隔加以区分。 示例： // Package superman implements methods for saving the world. // // Experience has shown that a small number of procedures can prove // helpful when attempting to save the world. package superman 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 \"Abcd...\" 作为开头。 示例： // enterOrbit causes Superman to fly into low Earth orbit, a position // that presents several possibilities for planet salvation. func enterOrbit() error { ... } godoc 工具会收集这些注释并产生一个技术文档。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"4. go程序的一般结构 下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main() 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。 所有的结构将在本文或接下来的章节中进一步地解释说明，但总体思路如下： 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init() 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。 如果当前包是 main 包，则定义 main() 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main() 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 package main import ( \"fmt\" ) const c = \"C\" var v int = 5 type T struct{} func init() { // initialization of package } func main() { var a int Func1() // ... fmt.Println(a) } func (t T) Method1() { // ... } func Func1() { // exported function Func1 // ... } Go 程序的执行（程序启动）顺序如下： 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序（自下往上）在每个包中初始化常量和变量，如果该包含有 init() 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main() 函数开始执行程序。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"5. 命名规范 干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。 名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。 返回某个对象的函数或方法的名称一般都是使用名词，没有 Get... 之类的字符，如果是用于修改某个对象，则使用 SetName()。 有必须要的话可以使用大小写混合的方式，如 MixedCaps() 或 mixedCaps()，而不是使用下划线来分割多个名称。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:5:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"1. 起源与发展 Go/Golang 起源于2007年，并于 2009 年正式对外发布，是一个完全开源的项目，背后的支持者是谷歌公司，它的主要目标是「兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性」。它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。 Go 的核心设计者是三位著名IT工程师：Ken Thompson，Rob Pike，Robert Griesemer。其中 Ken Thompson 是 Unix 操作系统的设计者，并因此获得图灵奖，也是 C 语言前身 B 语言的设计者，UTF-8 编码设计者之一，计算机史的重要人物，2006 年加入谷歌，和另外两人一起设计了 Go 语言。 Rob Pike 是 Ken 的老搭档。 随后又有 lan Lance Taylor 和 Russ Cox 两人加入团队，前者是 gccgo 编译器的作者和 cgo 工具链的维护者，后者加入团队后着手 Go 语言标准库的开发。 Go 语言以囊地鼠(Gopher)为图标和吉祥物，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。囊地鼠是一种原产于加拿大的啮齿类动物，Go 语言开发者也一般自称为 Gopher。 Go 语言相比于其它语言的最大优势在于它的执行性能与开发效率，这得益于 Go 在并发编程、内存回收等许多方面的良好设计，并因此大规模用于服务器编程、网络编程、数据库和云平台领域。 Go 是一种编译型的语言。它使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。 使用文本编辑器创建 Go 程序； 保存文件； 编译程序； 运行编译得到的可执行文件。 这不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤。Go 自带了编译器，因此无须单独安装编译器。 比较出名的 Go 语言项目有(不限于这些) Go语言本身： https://github.com/golang/go Docker： https://www.docker.com/ kubernetes： https://github.com/kubernetes/kubernetes Ethereum： https://github.com/ethereum/go-ethereum fabric： https://github.com/hyperledger/fabric Hugo： https://github.com/gohugoio/hugo TiDB： https://github.com/pingcap/tidb InfluxDB： https://github.com/influxdata/influxdb ETCD： https://github.com/etcd-io/etcd 使用 Go 的国外公司有：Google、Docker、NetFlix、CloudFlare、Dropbox、MongoDB、Uber等。 使用 Go 的国内公司有：七牛、字节跳动、bilibili、京东、百度、小米、腾讯、阿里等。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"2. 跟踪最新动态 最直接的方式是跟踪 Go 语言的源码库，关注提交历史和 issue 原始代码库： https://go.googlesource.com/go github镜像： https://github.com/golang/go 其它活跃论坛或动态 golang-dev：Google邮件列表的Go开发组讨论区 golang-nuts：Google邮件列表的Go讨论社区 golang-announce：发布Go版本或Go开发的最新状态 go.dev：2019.11.14上线的Go开发人员中心 gotime：Go的一个播客，每周一更，内容有干货 @golang：Go 语言在 Twitter 的官方帐号 Go 下载地址和相关的文档、标准库等访问地址为 官网 https://golang.org/ 国内的镜像网站 https://golang.google.cn/ Go语言中文网 是国内最活跃的Go社区，每周会发行一份 Go语言爱好者周刊 Go 相关资料聚集最多的还是 go wiki ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3. 下载安装 MacOS 下快速安装可以使用 Homebrew ，执行如下命令即可 $ brew install go 自动配置环境变量，安装完重启终端即可使用。 安装 Go 完成后，通过 brew list 查看，是否已安装成功。 用 go version 查看当前go的版本号。 需要升级 Go 语言版本的，输入以下命令： $ brew upgrade go 下面开始介绍常规的安装方法。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3.1 下载安装 Golang 中国官网下载页面为 golang.google.cn/dl，为 Windows、MacOS 和 Linux 三种环境都提供了安装包。 Windows 默认下载文件为 go1.20.windows-amd64.msi，双击启动即可安装，默认安装到Program Files 或Program Files (x86)。也可以根据需要更改位置。安装后，需要关闭并重新打开所有打开的命令提示符，以便安装程序对环境所做的更改反映在命令提示符中。环境变量将自动设置。但如果下载了以.zip为后缀的版本，则需要自己解压到合适的路径，并自己设置环境变量。 MacOS 默认下载文件为 go1.20.darwin-amd64.pkg，该软件包将 Go 发行版安装到 /usr/local/go。该包应将 /usr/local/go/bin 目录放入您的 PATH环境变量中。安装后，需要重新启动所有打开的终端会话才能使更改生效。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3.2 配置 打开终端配置代理 go env -w GOPROXY=https://goproxy.cn,direct ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4. 编辑器/IDE Golang 开发最流行的两个工具是 Goland 和 VScode，我自己是 VScode 的使用者。除了这两个工具外，官方还提供了一份IDE和插件列表。 VScode 中的 Go 扩展提供了大量的特性，如自动补全、悬停信息显示、括号匹配等，原本属于第三方开发者维护，现在交给了 Go 团队。详细的特性说明查看官网或是VS Code 中的 Go 扩展 Github 项目，下面进行一些简单介绍。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.1 Go工具链 微软在开发 VS Code 过程中, 定义了一种协议： 语言服务器协议 ，用来为每种语言提供诸如自动完成，代码提示等功能。gopls 就是Go语言的服务器。 当在 VS Code 中编辑 Go 代码时如果没有安装，VScode 会在右下角弹出提示，只要直接点击 Install 即可，不需要自己输入命令。默认使用了 GOPATH 作为安装路径。 如果没有弹出，则在 VS Code 中安装 Go 扩展插件 shift+command+p 搜索 \u003eGo: Insatall/Update Tools 全选后确定 分别包括了以下 7 种工具： gotests # 测试工具，根据函数签名生成测试用例。 gomodifytags # 一个修改 Go 源代码文件中结构体字段标签的 Go 工具。 impl # 一个根据其使用情况生成接口方法存根的 Go 工具。 goplay # 一个在线实验 Go 代码的游乐场。 dlv # Go 语言的调试器，它允许开发人员暂停程序执行，检查变量的值，设置断点，以及执行其他调试操作。 staticcheck # 一个 Go 静态检查工具，对 Go 源代码执行各种检查，包括检测潜在错误、找到代码缓慢、不安全或过于复杂的代码。 gopls # Go 语言服务器是一个为各种文本编辑器和集成开发环境（IDE）提供语言特定功能的工具，例如代码导航、代码完成和诊断等。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:1","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.2 用户和工作区设置 使用 VS Code 需要关心的一个重要部分是用户和工作区设置，几乎所有的事情都和它们有关。 这是两种不同的设置范围 用户设置：是一个全局的设置，适用于打开的任何VScode窗口 工作区设置：是指项目工作区的设置，只适用于对应的工作区（譬如某个文件夹） 工作区的设置会覆盖掉用户设置，它针对具体的项目，配置文件位于项目根目录.vscode文件夹，可与其它开发者共享。.vscode文件夹还用于存放调试配置和任务配置。 点击左下角的齿轮，选择设置，默认的设置界面是一个可视化的界面，不过也可以使用settings.json配置文件 用户设置文件在 Windows 中位于 %APPDATA%\\Code\\User\\settings.json 用户设置文件在 MacOS 中位于 ~/Library/Application Support/Code/User/settings.json 工作区设置文件位于根目录的 .vscode 文件夹中 请注意，~ 表示用户主目录。因此，如果您的用户名是 “Cloud”，则该文件位于： /Users/Cloud/Library/Application Support/Code/User/settings.json 如果文件不存在，您可以打开 VSCode，单击文件菜单，然后单击首选项 \u003e 设置。您可以在此处编辑设置，VSCode 将自动创建该文件。 最后，VScode大量的操作都可以通过命令完成，使用快捷键Ctrl+Shift+P可以打开命令输入框。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:2","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.3 特性说明 在用户或工作区设置中，将 go.autocompleteUnimportedPackages 设为 true ，可以在代码中点击包名跳转查看包的具体内容。 鼠标悬停在变量、函数和结构体的名称上方可以查看它们的签名等信息，这一功能需要 godoc 或 gogetdoc 实现，通过在用户或工作区设置中调整 go.docsTool 来切换工具。 代码导航功能无需设置默认实现。 对源码的保存操作会自动触发格式化、编译和代码质量检查。格式化工具可以通过调整go.formatTool来设置。 编译的过程使用go build命令。 代码质量检查的工具为golint，也可以使用gometalinter，用来检查代码的规范性，检查得到的errors和warning会在编辑器里以红色/绿色波浪线标出来，下面的输出窗口也会显示详细信息。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:3","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.4 调试 调试使用的是前面安装的delve工具。在 VScode 中，按F5启动调试，一般情况下使用默认的调试配置即可，不过还是应当对调试配置选项有一定的了解。 具体调试方法可查看 Debugging Go code using VS Code，更多关于 VS Code 中 Go 调试的相关信息都可查看该文档。 运行程序使用快捷键Ctrl+F5，和调试使用的是同一个配置文件。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:4","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"本系列主要介绍数据库和 SQL 的基础知识，使用的教材是SQL必知必会。 数据库(database)是保存有组织的数据的容器（通常是一个文件或一组文件）。简单来说，数据库是一个用于存储大量数据的系统。它允许你快速地存储、检索和更新数据。这些数据可以是客户信息、销售数据、财务数据等。 数据库又可根据数据的存储方式分成不同的种类，例如： 关系数据库（例如：MySQL、Oracle、SQL Server） 非关系数据库（例如：MongoDB、Redis） SQL (Structured Query Language:结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。 人们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统(DBMS) 数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:0:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"1. 关系型数据库 关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库是由多张能互相连接的表组成的数据库。 你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了的，而是先准备好一个资料袋，然后将相关的资料放入特定的资料袋中。在数据库领域中，这种资料袋称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。 优点 都是使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 数据存储在磁盘中，安全。 缺点 读写性能比较差，不能满足海量数据的高效率读写。 不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。 固定的表结构，灵活度较低。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:1:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"2. 非关系数据库（NoSQL） 非关系型数据库被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 优点 非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。 海量数据的维护和处理非常轻松。 非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。 可以实现数据的分布式处理。 缺点 非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。 非关系数据库没有事务处理，没有保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。 功能没有关系型数据库完善。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:2:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"3. MySQL 为了更好地应用SQL，我们需要安装一个MySQL便于学习过程中进行练习。 MySQL 是最流行的数据库之一，是一个免费开源的关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 适合中小型软件，被个人用户以及中小企业青睐。 针对不同的用户，MySQL 分为两个版本： MySQL Community Server（社区版）：该版本是自由下载且完全免费的，但是官方不提供技术支持。 MySQL Enterprise Server（企业版）：该版本是收费的，而且不能下载，但是该版本拥有完善的技术支持 MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20： 第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。 第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。 第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。 MySQL 的主要特点就是免费，并且在任何平台上都能使用，占用空间相对较小。 MySQL 是 C/S 架构，有 Client 和 Server 两部分，可以都安装在一台电脑上，也可以独立安装。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:3:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"4. 安装与配置 官方下载页面：https://dev.mysql.com/downloads/ MacOS安装可参考这个视频： ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:4:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"5. 图形化管理工具 常用的图形化管理工具有 MySQL Workbench 和 Navicat，前者是官方提供的工具，但后者比较好用。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:5:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"6. SQL 对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。SQL包括四部分 数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令：- SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 我们将在接下来的几篇文章中学习它们。 SQL 的几个易错书写规则如下 以分号 ; 结尾 SQL 语句不区分大小写 单词需要半角空格或换行来分隔 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:6:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"Hugo 是由 Go 语言实现的静态网站生成器，可以快速建立一个静态网站，虽然多数情况下用来搭建个人博客，但也可以用作展示在线书籍、个人简历等。 最早我也是使用 Hugo 搭建的个人博客，由于之前才疏学浅，我所使用的博客出现了一些 bug，我无法修复，因此也很久没有更新过文章。借着 2023 年的春节，我重新搭建了这个博客。其中很多细节已经忘记了，因此耗费了我不少时间，为了节约精力，因而有了这篇文章小记，方便自己以及后人。 本文用来记录 Hugo 使用种遇到的问题和积累的经验。本文是第一篇（也许也是最后一篇），介绍博客网站搭建的过程和一些基础配置。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"1. 安装Hugo 安装Hugo前请确保您的电脑上已安装了 Git 和 Go 。 详细的安装说明参见官方文档，这里简单介绍 MacOS 的快速安装。 MacOS 下可自行从官网下载软件包安装，也可以使用 Homebrew 包管理工具快速安装 # 更新homebrew到最新 % brew update # 安装hugo（用homebrew默认安装扩展版本） % brew install hugo # 检查安装 % brew list 注意要安装 extended 版本，主要是因为很多主题都需要扩展版的功能，如果确认自己的主题不需要(阅读主题说明)，可以按照正常的版本。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"2. 生成博客网站 执行下面的命令在本地生成博客网站项目文件夹，该文件夹是这一系列文章之后所有操作执行的根目录(简称为项目根目录)，我建立的项目文件夹名为 cloud1998.github.io （因为之后要使用 Github Pages 托管博客）。 % hugo new site cloud1998.github.io % cd cloud1998.github.io blog 文件夹的目录结构如下所示： % ls config.toml layouts static archetypes content themes assets data resources 其中： config.toml 是博客的配置文件 content 是博客文章存放的地方 themes 是博客主题目录 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"3. 安装主题 Hugo没有默认主题，需要自己从官方的主题列表下载安装。其中 LoveIt 是我喜欢的主题。因为主题通常是单独的 Github 仓库，因此将其作为博客项目的子模块进行管理。 # 初始化项目目录为 git 仓库 git init # 将主题项目作为子模块添加 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 复制主题提供的站点配置文件 config.toml 到项目根目录，覆盖 Hugo 本身的站点配置文件。 请打开下面的代码块查看完整的配置⬇️： baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"我的网站\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"这是我的全新 Hugo 网站\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"我的网站\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4. 网站配置 正式使用前，我们需要编辑站点配置文件从而设置网站的一些内容，上面的配置文件已经进行了详细的说明，如有更多疑问请查阅LoveIt官方主题文档。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4.1 头像 新建static/images文件夹，将头像文件 avatar.png 存放在这里。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:1","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4.2 网站图标 使用 favicon generator 生成配套的网站图标，放到 /static 目录下，可以设置网站在各平台的显示图标，包括如下内容 android-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml cover.png favicon.ico favicon-16x16.png favicon-32x32.png logo.png mstile-150x150.png safari-pinned-tab.svg site.webmanifest 然后修改站点配置文件中的配置项即可。 更多配置可以参考Mogeko的个人博客 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:2","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5. 托管到Github 将本地的所有项目文件提交到本地仓库中。 % git add . % git commit -m \"Initial commit\" 浏览器打开 Github 网站，创建和项目文件夹同名的仓库，该仓库用于存储项目文件夹下所有内容。创建完成后，在本地项目根目录，执行下列命令，将项目文件推送到远程仓库。 % git remote add origin https://github.com/cloud1998/cloud1998.github.io.git % git push -u origin main 关于网页如何托管在Github的详细说明可以参考Host on Github ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5.1 源码备份 按照 Hugo 的生成规则，执行 hugo 命令后，网站静态文件将会生成在 public 文件夹。但由于我们使用 Github Pages 托管博客网站，该功能启用后 Github 仓库只会从 main branch 或 main branch 中的 /docs 目录下读取网站源码。 我们解决这一问题的方法是新建 blog 分支将博客源码放在该分支下，利用 Github Action 自动根据 blog 分支的博客源码执行 hugo 命令，并将生成的结果推送到 main 分支。首先在本地项目根目录下执行下列命令新建并切换到 blog 分支。 注：Github Action 的说明见附录I % git checkout -b blog % git branch * blog main # 将新分支推送到远程仓库 并建立跟踪关系 % git push -u origin blog 在使用 “git push” 时，第一次推送新分支时，需要使用 “–set-upstream” 或 “-u” 选项，以便在远程仓库中设置跟踪关系。 将本地 blog 分支的内容推送到远程仓库后，在网页端进入cloud1998.github.io仓库的设置页面，将默认分支设置为 blog 分支。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:1","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5.2 推送到main分支 首先生成公私钥供 Github Action 使用 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f blog -N \"\" # You will get 2 files in current file: # blog.pub (public key) # blog (private key) 然后进入 cloud1998.github.io 仓库设置页面，在 Deploy Keys 中添加公钥，在 Secrets 中添加私钥，私钥名设置为 ACTIONS_DEPLOY_KEY 接着新建 YAML 配置文件，Github Action 要求配置文件位于 .github/workflows 目录下，新建完成后目录结构如下 $ ls ./.github/workflows main.yml Github Action使用一种模块化的思路，即将很多持续集成的操作写成独立的脚本文件，放到代码仓库，让其它开发者使用。因此进行持续集成时，可以直接引用别人写好的 action，整个持续集成的过程，就是一个 actions 组合的过程。GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 我们的基本思路如下 整个流程在 blog 分支 push 时触发 只有一个job，运行在ubuntu-20.04环境下 使用官方提供的 action/checkout 获取仓库源码，注意添加参数clone主题子模块 使用 peaceiris/actions-hugo: GitHub Actions for Hugo 部署 hugo 环境，注意使用 extentded 版本（主题要求） 直接执行 hugo 命令 使用 peaceiris/actions-gh-pages 将执行的结果部署到GitHub Pages的源目录，默认即main分支的目录下。 完整的main.yml脚本内容如下 name:hugopushtogithubpageson:push:branches:- blogjobs:build-deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v1with:submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.63.2'extended:true- name:Buildrun:HUGO_ENV=productionhugo--gc--minify- name:Deployuses:peaceiris/actions-gh-pages@v2env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}PUBLISH_BRANCH:mainPUBLISH_DIR:./public 保存上面的文件后，将本地仓库推送到远程，Github 检测到 .github/workflow 目录和里面的main.yml 文件，就会自动运行，在网页端可以查看运行日志，如果出现错误可以根据日志内容就行修改。 等到 workflow 运行结束，访问博客页面，就可以看到更新成功了。切换到 main 分支，也可以看到推送的网页文件，不过因为设置了默认分支为 blog，以后打开网页端该仓库，以及在本地 clone 的时候，默认都是 blog 分支。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:2","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"6. 文章发布 在 content 目录下创建 posts文件夹，写作的文章全部放到该目录下，在每篇文章开头添加元数据字段，可以是YAML或TOML格式，示例如下 title = \"Getting Started with Hugo\" description = \"\" type = [\"posts\",\"post\"] tags = [ \"go\", \"golang\", \"hugo\", \"development\", ] date = \"2014-04-02\" categories = [ \"Development\", \"golang\", ] series = [\"Hugo 101\"] [ author ] name = \"Hugo Authors\" 下面是一篇示例文章 --- title: 示例文章 date: 2023-01-30 tags: [\"博客搭建\"] categories: [\"编程技术\"] --- 这是一篇示例文章。 文章保存后将仓库新增内容推送到远程仓库： % git add . % git commit -m \"更新了一篇文章\" % git push 几分钟后即可在 https://cloud1998.github.io 看到这篇文章。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"附录I Github Action GitHub Actions 是 GitHub 在2018年10月推出的一个持续集成服务，之前一直是试用阶段，2019年末开放，据说比Travis CI 更简单更好用。 Github Actions入门可以阅读官方文档或者阮一峰大神的GitHub Actions 入门教程。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"这是我的第一篇hugo文章。 ","date":"2023-01-29","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"我们已经在一起 var countDownDate=new Date(\"2022-09-28T19:40:00\").getTime();window.setInterval(function(){var e=(new Date).getTime()-countDownDate,t=Math.floor(e/(1e3*60*60*24)),n=Math.floor(e%(1e3*60*60*24)/(1e3*60*60)),s=Math.floor(e%(1e3*60*60)/(1e3*60)),o=Math.floor(e%(1e3*60)/1e3);document.getElementById(\"since\").innerHTML=t+\" 天 \"+n+\" 时 \"+s+\" 分 \"+o+\" 秒\"},1e3) ","date":"2022-09-28","objectID":"/since/:0:1","tags":null,"title":"Since 2022/09/28","uri":"/since/"},{"categories":null,"content":"关于网站 | 个人博客，欢迎交流 ","date":"2022-02-03","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者 ❤️ 爱好游戏、电影 ","date":"2022-02-03","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]