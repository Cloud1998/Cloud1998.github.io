[{"categories":["编程技术"],"content":"本文介绍 Golang 中的运算符和流程控制。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"1. 运算符 Go 语言的运算符有 6 种，如下表所示： 运算符类型 运算符 算术运算符 +，-，*，/，%，++，– 关系运算符 ==，!=，\u003e，\u003c，\u003e=，\u003c= 逻辑运算符 \u0026\u0026，||，! 位运算符 \u0026，|，^，«，»，\u0026^ 赋值运算符 =，+=，-=，*=，/=，%=，«=，»=，\u0026=，^=，!= 其它运算符 \u0026，* 基本的运算规则都与 C 语言相同，一些注意事项列举如下： 算术运算符中自增自减运算符只能作为语句使用，不能用于表达式： a++ // 允许 a-- // 允许 a = a++ //不允许，编译错误 a[i] = b[i++] //不允许，编译错误 整数除以 0 会导致编译错误，如果编译时未检出会导致程序崩溃。浮点数除以 0.0 会返回无穷大，用+Inf表示。 逻辑运算符具有短路效果，即当逻辑运算符左边表达式的值已经能够决定整个表达式的值的时候逻辑运算符右边的表达式将不会被执行。 位运算符是对整数在内存中的二进制位进行操作的，它只能用于整数类型的变量，且需它们拥有等长位模式。 假定 A = 60，B = 13，则 A = 0011 1100 B = 0000 1101 A \u0026 B = 0000 1100 // 结果为12 A | B = 0011 1101 // 结果为61 A ^ B = 0011 0001 // 结果为49 A \u003c\u003c 2 = 1111 0000 // 结果为240 A \u003e\u003e 2 = 0000 1111 // 结果为15 其它运算符中的\u0026是取地址符，*是指针变量。 运算符的优先级是不同的，下表从上往下代表优先级从高到低： 优先级 运算符 7 ^ ! 6 * / % « » \u0026 \u0026^ 5 + - | ^ 4 == != \u003c \u003c= \u003e \u003e= 3 \u003c- 2 \u0026\u0026 1 || 二元运算符的运算方向均是从左到右，必要时可以使用括号提升优先级或更清楚地表达。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2. 控制结构 除去顺序结构外，Go 语言提供的基本流程控制结构包括 条件结构 if-else 结构 switch 结构 select 结构，用于 channel 的选择（协程与通道部分） 循环结构 for for-range 同时，Go 还提供了关键字break、continue和goto用来辅助进行流程控制，以及return语句提前结束执行。 注意 在这些结构中，Go 都省略了条件语句两侧的小括号，使视觉上更加简洁。 除case关键字后的语句，即使代码块只有一行，大括号也不可省略 左大括号必须和关键字在同一行，对多分支结构中的else关键字，右大括号也要和它在一行。这两条规则是编译器的强制规定。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.1 if-else 结构 if-else 结构的基本形态与C语言相同。可以省略else关键字变成单分支结构，也可以添加else if变成多分支，但为了代码简洁，过多的分支最好换用 switch 结构实现。 if condition1 { // do something } else { // do something else } 当双分支结构在代码块的末尾时，通常会将 else 中原本的代码块迁移出来放在最后，如： if condition { return true } return false Go 中 if 还可以在条件语句前添加一个初始化语句，以分号分隔： if initialization; condition { // do something } 例如： if val := 10; val \u003e max { // do something } 但需要注意的时，使用简短方式 := 声明和初始化的变量作用域只限于 if 结构的代码块内，属于局部变量。 由于 Go 语言并行赋值的特性，if 语句经常用于测试多返回值函数的错误。返回某个值以及 true 表示成功，返回零值（或 nil）以及 false 表示失败： if value, ok := readData(); ok { ... } 当不使用 true 或 false 时，也可以使用一个 error 类型的变量来代替作为第二个返回值，成功执行，则 error 的值为 nil；否则执行失败，返回的值会包含相应的错误信息： var err error if err := file.Chmod(0664); err != nil { fmt.Println(err) return err } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.2 switch 结构 switch 结构的基本形态依然同 C 语言相同： switch var1 { case val1: ... case val2: ... default: ... } 不同的是，Go 中 switch 语句接受任意形式的表达式，如上例中 var1 可以是任何类型，而 val1 和 val2 可以是同类型的任意值，不局限于数值。 可以同时测试多个可能符合条件的值，使用逗号分隔，例如case val1, val2, val3 每个case分支都是唯一的，从上到下逐一测试，一旦成功匹配到某个分支，执行完对应的代码块后会自动退出整个 switch 结构，而不需要使用break结束。因此，程序不会自动的去执行剩下的 case 分支的代码，如果想继续执行，需要使用 fallthrough 关键字： switch i { case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用 } 注意 fallthrough 语句执行后，就不会再判断变量 i 是否满足分支，后续所有分支内的代码均会被无条件执行！ case 语句后不需要用大括号包围代码块，default 分支可以出现在任何顺序，但最好放在最后： package main import \"fmt\" func main() { var num1 int = 100 switch num1 { case 98, 99: fmt.Println(\"It's equal to 98\") case 100: fmt.Println(\"It's equal to 100\") default: fmt.Println(\"It's not equal to 98 or 100\") } } //Output: //It's equal to 100 switch 可以不提供条件语句，然后在每个 case 分支测试不同条件，可以替换分支比较多的if-else结构，简化代码： switch { case i \u003c 0: f1() case i == 0: f2() case i \u003e 0: f3() default: ... } switch的条件语句还可以是初始化语句： switch a, b := x[i], y[j] { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:2","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.3 for 结构 Go 中只有 for 用于循环结构，没有 C 中的 while 或 do while，基本形态如下： for 初始化语句; 条件语句; 修饰语句 { ... } 同样，for 关键字后的三个语句不需要小括号，左大括号需和关键字在同一行： 可以只保留条件语句，这种情况下可以去掉所有分号，大致等同于其它语言的 while 循环： package main import \"fmt\" func main() { var i int = 5 for i \u003e= 0 { i = i - 1 fmt.Printf(\"The variable i is now: %d\\n\", i) } } 或者省略条件语句，但必须在循环体中存在条件判断以确保在某个时候退出循环，退出可以使用break或return： for i := 0; ; i++ { ... } 或者三条语句全部省略，但同样需要在循环体中添加退出条件： for { ... } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:3","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"2.4 for-ranges 结构 这是 Go 中特有的迭代结构，可以迭代数组、切片、map、字符串等任意一个集合，一般形式为： for k, v := range set { ... } k 为索引，每次递增，v 为索引对应的值的拷贝。值得注意的是，由于 v 只是值的拷贝，任何对它的修改都不会影响集合中原来的值，除非索引是指针。 如果不需要索引，可以使用匿名变量_忽略它： for _, v := range set { ... } 但如果只需要索引而不需要值，可以直接省略不写： for k := range set { ... } // Output: 0 1 2 ... 字符串通过 for-range 结构获取的元素是 rune 类型。 ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:4","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"3. 辅助语句 控制结构中，常用的辅助语句有：break、continue、goto、return。 break 用来跳出循环，在 for 循环中跳出一层循环，在 switch 或 select 语句中，跳过整段代码块： for i:=0; i\u003c3; i++ { for j:=0; j\u003c10; j++ { if j\u003e5 { break } print(j) } print(\" \") } // Output: // 012345 012345 012345 continue 用来忽略剩余的循环体直接进入下一次循环，只存在于for循环中： for i := 0; i \u003c 10; i++ { if i == 5 { continue } print(i) print(\" \") } // Output: // 0 1 2 3 4 6 7 8 9 for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词，下例中 continue 语句指向 LABEL1，当执行到该语句时，就会跳转到 LABEL1 标签的位置起继续执行，不过此时注意循环体内的变量并不会被释放，当 j==4 循环跳出后，i 会自动变成下一个循环的值，不会陷入无限循环。 package main import \"fmt\" func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } 标签的名称和一般的标识符相同，都是大小写敏感的，但为了可读性，一般全部使用大写字母。同变量相同，标签定义未使用也会导致编译错误。 goto 关键字是配合标签使用的，但这种用法并不被推荐，因为很可能导致糟糕的代码结构，一如当年的 PASCAL。 逆序的标签虽然可能导致错误，但正序的标签（标签位于 goto 语句之后）则可以正常使用，但标签和 goto 之间不能有新定义变量的语句，否则会导致编译失败。 // compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8 package main import \"fmt\" func main() { a := 1 goto TARGET // compile error b := 9 TARGET: b += a fmt.Printf(\"a is %v *** b is %v\", a, b) } ","date":"2023-02-10","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础4-运算符与流程控制","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%804-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的常量、变量、基本数据类型和常用的类型转换。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"1. 常量 常量用于存储程序运行过程中恒定不变的数据，因此我们无法在程序运行过程中修改它的值，如果你在代码中试图修改常量的值则会引发编译错误。Go语言中使用关键字 const 定义常量，格式如下： const identifier [type] = value 常量的值必须在编译时能够确定，因此只能是基本数据类型和表达式。一个常量定义的例子如下： const Pi float64 = 3.1415926 存储在常量中的数据类型只可以是：布尔型、数字型（整数型、浮点型和复数）和字符串型。 另外，由于 Go 的特性，常量的定义具有一些不同的形式： 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 const Pi 3.1415926 Go 支持在同一行同时定义多个值，称为并行赋值。 const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday = 1, 2, 3, 4, 5, 6, 7 Go 支持批量声明，这种定义形式叫做因式分解关键字。 const ( Monday, Tuesday, Wednesday = 1, 2, 3 Thursday, Friday, Saturday = 4, 5, 6 Sunday = 7 ) 未定义类型的常量会在必要时刻根据上下文来获得相关类型。例如： var n int f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。 正确的做法：const c1 = 2 / 3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出： const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 const Log2E = 1 / Ln2 // this is a precise reciprocal const Billion = 1e9 // float constant const hardEight = (1 \u003c\u003c 100) \u003e\u003e 97 根据上面的例子我们可以看到，反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。 此外，Go 还提供关键字 iota，用作常量计数器，只能在常量定义时使用。iota 在 const 关键字出现时被重置为 0，每新增一行常量声明新增一个计数，能极大的简化定义。一个例子如下： const a = iota // a = 0 const ( b = iota // b = 0 c = iota // c = 1 ) 可以使用空白标识符跳过不想要的值： const ( a = iota // a = 0 _ = iota // _ = 1 空白标识符可以简单地理解为一个“只写”的变量 c = iota // c = 2 ) 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式： const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) 同一行有多个常量不产生影响，中间有数值插队也不产生影响，因为 iota 的值是每新增一行声明增加 1： // 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次 const ( Apple, Banana = iota + 1, iota + 2 // Apple = 1 Banana = 2 Cherimoya, Durian // Cherimoya = 2 Durian = 3 Elderberry, Fig // Elderberry = 3, Fig = 4 ) iota 也可以用在表达式中参与运算操作，如： // 使用 iota 结合位运算表示资源状态 const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) // 使用 iota 结合乘法运算表示单位 const ( _ = iota // 使用 _ 忽略不需要的 iota KB = 1 \u003c\u003c (10 * iota) // 1 \u003c\u003c (10*1) MB // 1 \u003c\u003c (10*2) GB // 1 \u003c\u003c (10*3) TB // 1 \u003c\u003c (10*4) PB // 1 \u003c\u003c (10*5) EB // 1 \u003c\u003c (10*6) ZB // 1 \u003c\u003c (10*7) YB // 1 \u003c\u003c (10*8) ) iota小结 只能在定义常量时使用 遇到const关键字重置为0 每次换行声明，iota的值就会增加1 关于 iota 的使用涉及到非常复杂多样的情况，这里解释的并不清晰，因为很难对 iota 的用法进行直观的文字描述。如希望进一步了解，请观看视频教程 《Go编程基础》 第四课：常量与运算符。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"2. 变量 声明变量的一般形式是使用 var 关键字 var identifier type 当一个变量被声明后，系统会自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。 也可以在声明的同时初始化： var a int = 15 最后，由于常量部分提到的三个 Go 的特性，变量的声明和使用也有一些不同的形式： 类型推断，从而可以省略类型定义 var a = 15 并行赋值 var a, b, c = 5, 6, 7 因式分解关键字（一般用于声明全局变量） var ( a = 15 b = false str = \"Go says hello to the world!\" numShips = 50 city string ) 上面提到的所有方式可以用于全局变量，也可以用于局部变量，但还有一种更加简短的声明与定义方式，仅能用于局部变量（函数体内，包括 main 函数），这是我们使用非常多的一种写法： a := 15 这里详细介绍一下常量部分提到过的空白标识符，空白标识符指的是下划线 _，也叫做匿名变量，只允许写入，任何类型都可以赋值给它，但无法使用它的值。我们在使用 iota 关键字时可以使用空白标识符跳过不想要的值，另外一种常见的使用场景是在多重赋值中抛弃不需要的变量。 _, b = 15, 7 匿名变量不会被分配内存，因此不占用内存空间，多次声明也不会引起冲突。 Go 还提供了一种非常友好的功能，如果想要交换两个变量的值，可以直接使用 a, b = b, a 这种形式，不需要再使用临时变量，为程序编写带来了极大的便利。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（可见性规则）。 变量作用域的规则同 C 语言相同，关于值类型和引用类型的理解也和 C 语言相同。 Go 中值类型包括int、float、bool、string、数组、结构体（struct），引用类型包括指针、切片（slices）、映射（maps）和通道（channel）。值类型存储在栈中，引用类型存储在堆中，以便进行垃圾回收。 注意 := 是声明语句。如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： func main() { var a string = \"abc\" fmt.Println(\"hello, world\") } 尝试编译这段代码将得到错误 a declared and not used。 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 fmt.Println(\"hello, world\", a) 会移除错误。 全局变量允许被声明但是不使用。 为什么将变量的类型放在变量的名称之后？ 首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。 而在 Go 中，则可以很轻松地将它们都声明为指针类型：var a, b *int 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3. 基本数据类型 Go 拥有 4 大类共7种基本数据类型 布尔类型 bool 数字类型： 整型 int，根据位数的不同包括 int8, int16, int32, int64 四种以及相对应的 uint 浮点型 float，包括 float32 和 float64 两种 复数 complex，包括 complex32 和 complex64 两种，复数类型并不常用 字符类型： byte，uint8 的别名，完全等同 rune，int32 是别名，完全等同 字符串类型 string Go 语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较。我们将 Go 中不可比较类型总结如下，除此之外，其它类型都是可比较的： 切片类型 映射类型 函数类型 任何字段为不可比较类型的结构体类型，以及任何元素类型为不可比较类型的数组类型 对于接口而言，情况更加复杂一点，如果值的类型是接口，那么它们必须实现了相同的接口。如果条件不满足，则必须事先进行类型转换才可以比较。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.1 布尔类型 使用bool关键字声明，值只可以是常量 true 或 false。 var b bool = true 两个类型相同的值可以使用关系运算符（==和!=）来获得一个布尔类型的值。布尔类型的值之间也可以使用逻辑运算符（!、\u0026\u0026、||）来产生另一个布尔值，运算规则与其它语言相同。 提示 Go 中的布尔值并不等于数字 1 和 0，因此不能直接进行运算。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.2 数字类型 Go 中数字类型分为三种，整型、浮点型和复数类型，其中位的运算采用补码。 整型 整型提供有符号和无符号两种，每一种又分别提供对应 8、16、32、64bit 大小的四种类型，总计八种，列表如下： 整型 无符号整型 int8（-128 -\u003e 127） uint8（0 -\u003e 255） int16（-32768 -\u003e 32767） uint16（0 -\u003e 65,535） int32（-2,147,483,648 -\u003e 2,147,483,647） uint32（0 -\u003e 4,294,967,295） int64（-9,223,372,036,854,775,808 -\u003e 9,223,372,036,854,775,807） uint64（0 -\u003e 18,446,744,073,709,551,615） 除此之外还提供两种不带位数的类型声明：int 和 uint。这两种类型的大小取决于所运行的平台处理器支持的字长，例如，在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 提示 你可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。 尽管 int 有可能是 32 位，但在需要时 int 和 int32 之间也必须显式进行类型转换。 最后还有一种无符号整型 uintptr，它没有指定具体的 bit 大小但被设定为足够容纳一个指针。uintptr 类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方，一般用于指针计算。 int 型是计算最快的类型，也是最常使用的类型。 提示 你可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。 浮点型 Go 语言中没有 float 类型，没有 double 类型，只有 float32 和 float64。它们的算术规范由 IEEE-754 标准定义，该标准被所有现代的 CPU 支持。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。通常应该优先使用 float64 类型，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 复数类型 Go 语言拥有两种复数类型，分别是 complex64（32 位实数和虚数）和 complex128（64 位实数和虚数）。 var c1 complex64 = 5 + 10i // 5 是实部 10i 是虚部 内置的 complex 函数用于构建复数，内置的 real 和 imag 函数分别返回复数的实部和虚部： var cl complex128 = complex(1, 2) // 1+2i fmt.Println(real(cl)) // \"1\" fmt.Println(imag(cl)) // \"2\" cmath 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.3 字符类型 Go语言的字符有两种： byte 型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。 严格来说，字符并不是 Go 语言的一种类型，字符只是整数的别名，因此其零值也是 0。在声明时应使用单引号括起来。 byte 类型是 uint8 的别名，刚好一个字节，足以表示传统 ASCII 编码的字符。例如：var ch byte = 'A'； rune是int32的别名，四个字节，足以表示最长的 UTF-8 字符。例如：var ch rune = '\\u0041'。 提示 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \\u 或者 \\U。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U 前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:3","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.4 字符串类型 字符串底层约定是字节的一个序列，编码方式建议是 UTF-8，但不是必须遵守，通常是 ASCII。因此取字符串单个字符的类型通常是 byte，只有遇到中文等语言是才是 rune。另外，使用 for-range 结构遍历时字符串的单个字符类型是 rune。 字符串是值类型，且值不可变，即创建一个字符串后无法再次修改它的内容 Go 支持以下 2 种形式的字符串： 解释字符串：该类字符串使用双引号括起来，其中的转义字符将被替换，这些转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U：Unicode 字符 \\\\：反斜杠自身 非解释字符串：该类字符串使用反引号括起来，当使用多行字符串时使用这种形式。 a := `abc def` fmt.Println(a) // Output: abc def string 类型的零值为长度为零的字符串，即空字符串 \"\"。 Go 中的字符串是根据长度限定的，而非特殊字符\\0，其长度可以使用内置函数len()来获取，长度的基本含义是字符串在内存中所占字节的个数，所以下面的例子虽然是两个中文，但长度是6 a := \"中国\" fmt.Println(len(a)) // 6 可以将字符串看作数组而索引其内的单个字符，如第 i 个字节表示为str[i-1]。 注意 获取字符串中某个字节的地址的行为是非法的，例如：\u0026str[i]。 使用拼接符+可以拼接两个字符串，以下是一个多行字符串拼接的例子 str := \"Beginning of the string \" + \"second part of the string\" +必须放在第一行末尾，因为编译器会在行尾自动补全分号。当然，+=一样可用于字符串 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) // 输出 “hello, world!” 在循环中使用+拼接字符串并不是最高效的做法，更好的办法是使用string.join()，或者使用字节缓冲bytes.Buffer。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:4","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"3.5 类型别名 使用某个类型时可以给它起个别名在程序中使用，用于简化名称或解决名称冲突。 在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 package main import \"fmt\" type TZ int func main() { var a, b TZ = 3, 4 c := a + b fmt.Printf(\"c has the value: %d\", c) // 输出：c has the value: 7 } 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法；TZ 可以自定义一个方法用来输出更加人性化的时区信息。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:5","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4. 类型转换 Go语言中类型转换是可行的，但是不存在隐式类型转换，所有的转换都必须显式说明。类型转换的基本格式为： valueOfTypeB = typeB(valueOfTypeA) 两条转换原则如下： 只有相同底层类型的变量间可以进行相互转换（如 int16 和 int32），不同底层类型的变量相互转换会引发编译错误。 类型转换只有从取值范围小的类型转换到取值范围大的类型才能成功，反过来会发生精度丢失（截断）。 var a, b int16 var c int32 A := int32(a) // 标准转换 B := bool(b) // 类型不匹配，引发编译错误 C := int16(c) // 取值范围变小，精度丢失 浮点型可以转换为整型，转换时会将小数部分去掉，只保留整数部分： a := 12.54 fmt.Println(int(a)) // 输出12 精度丢失可以使用专门的函数保证安全，如 int 型到 int8： func Uint8FromInt(n int) (uint8, error) { if 0 \u003c= n \u0026\u0026 n \u003c= math.MaxUint8 { // conversion is safe return uint8(n), nil } return 0, fmt.Errorf(\"%d is out of the uint8 range\", n) } 其它的类型转换则需要使用一些库函数。 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.1 bool 与 string Go 语言中 bool 类型值与数字 1 和 0 不等同，因此不能和数字类型相互转换（可以简单的使用 if-else 结构完成这一功能）。但借助 strconv 包，可以和 string 类型转换。 // string -\u003e bool b, err := strconv.ParseBool(\"true\") // bool -\u003e string s := strconv.FormatBool(true) 两个函数的原型如下： // ParseBool返回字符串代表的bool值，接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False作为传入参数，其他参数均返回error func ParseBool(str string) (bool, error) { switch str { case \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\": return true, nil case \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\": return false, nil } return false, syntaxError(\"ParseBool\", str) } // FormatBool returns \"true\" or \"false\" according to the value of b. func FormatBool(b bool) string { if b { return \"true\" } return \"false\" } ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:1","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.2 int / float 与 string 与字符串相关的类型转换都是通过 strconv 包实现的。最常用的是 Atoi(string to int) 和 Itoa(int to string) 函数： i, err := strconv.Atoi(\"-42\") s := strconv.Itoa(-42) 函数原型如下 func Atoi(s string) (int, error) func Itoa(i int) string 字符串-\u003e数字类型 ParseFloat, ParseInt, 和 ParseUint 可以将字符串转化为对应的值： f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-42\", 10, 64) u, err := strconv.ParseUint(\"42\", 10, 64) 浮点型函数原型如下： func ParseFloat(s string, bitSize int) (float64, error) bitSize指定了返回值的类型，当 bitSize=32，返回 float32 类型（结果仍是 float64，但会转换为 float32)；当 bitSize=64，返回 float64 类型。只有这两种情况。 整型函数原型如下： func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (uint64, error) 如果 base 为 0 那么实际上 base 由 string 的前缀指定，0x意味着 base=16，0意味着 base=8，否则 base=10，本质上是进制的前缀。若base等于1，小于0或超过36，返回一个error。 bitSize 仍然指定返回值类型. 其值为 0, 8, 16, 32, 和 64 分别对应 int, int8, int16, int32 和 int64. bitSize 值小于 0 或大于 64 ，返回一个 error。 数字类型-\u003e字符串 FormatFloat, FormatInt, 和 FormatUint 可以将值转换为字符串： s := strconv.FormatFloat(3.1415, 'E', -1, 64) s := strconv.FormatInt(-42, 16) s := strconv.FormatUint(42, 16) 浮点型的函数原型如下： func FormatFloat(f float64, fmt byte, prec, bitSize int) string bitSize 表示 f 的来源类型（32：float32、64：float64），会据此进行舍入。 fmt 表示格式：‘b’ (-ddddp±ddd, 二进制指数), ‘e’ (-d.dddde±dd,十进制指数), ‘E’ (-d.ddddE±dd, 十进制指数), ‘f’ (-ddd.dddd, 没有指数), ‘g’ (指数很大时用‘e’, 否则用 ‘f’ ), ‘G’ (指数很大时用‘E’, 否则用 ‘f’ ). 精度 prec 控制数字的个数 (排除指数)。对’e’, ‘E’, 和 ‘f’ ，表示小数点后的数字位数. 对 ‘g’ 和 ‘G’ 是有效数字位数 (trailing zeros are removed)。prec 等于 -1 时则使用最少数量但又必须的数字来表示 f。 整型的函数原型如下： func FormatInt(i int64, base int) string func FormatUint(i uint64, base int) string 返回 base 指定进制的整数 i 的字符串形式，2 \u003c= base \u003c= 36。使用小写字母 ‘a’ 到 ‘z’ 表示大于10的数字。 忽略可能出现的转换错误，可以给出如下例子： package main import ( \"fmt\" \"strconv\" ) func main() { var orig string = \"666\" var an int var newS string an, _ = strconv.Atoi(orig) fmt.Printf(\"The integer is: %d\\n\", an) an = an + 5 newS = strconv.Itoa(an) fmt.Printf(\"The new string is: %s\\n\", newS) } //输出： The integer is: 666 The new string is: 671 ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:2","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"4.3 []rune 与 string 用 for range 遍历字符串可以返回每个字符，返回的字符类型是 rune。但 []rune 类型也经常需要转换为 string，和单个 rune 类型相似，都可以直接进行显示类型转换，如下： a := []rune{'a', 'b', 'c'} b := 'g' c := string(a) d := string(b) fmt.Println(reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c), reflect.TypeOf(d)) fmt.Println(a, b, c, d) //Output []int32 int32 string string [97 98 99] 103 abc g ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:3","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"5. init函数 变量除了可以在全局声明中初始化，也可以在 init() 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main() 函数高。 每个源文件可以包含多个 init() 函数，同一个源文件中的 init() 函数会按照从上到下的顺序执行，如果一个包有多个源文件包含 init() 函数的话，则官方鼓励但不保证以文件名的顺序调用。初始化总是以单线程并且按照包的依赖关系顺序执行。 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 // init.go package trans import \"math\" var Pi float64 func init() { Pi = 4 * math.Atan(1) //init() function computes Pi } 在它的 init() 函数中计算变量 Pi 的初始值。 下面的代码导入上文所创建包 trans（需要 init.go 目录为 ./trans/init.go ）并且使用到了变量 Pi： package main import ( \"fmt\" \"./trans\" ) var twoPi = 2 * trans.Pi func main() { fmt.Printf(\"2*Pi = %g\\n\", twoPi) // 2*Pi = 6.283185307179586 } init() 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 backend()： func init() { // setup preparations go backend() } ","date":"2023-02-05","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["Golang语法基础"],"title":"Golang语法基础3-常量、变量与基本数据类型","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%803-%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["编程技术"],"content":"本文介绍 Golang 中的基本程序结构和语法。让我们从经典的 HelloWorld 程序开始。 package main import \"fmt\" func main(){ fmt.Println(\"hello, world\") } ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:0:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"1. 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。 标准库 在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。 Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。 如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。 Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。 如果 A.go 依赖 B.go，而 B.go 又依赖 C.go： 那么编译顺序是：编译 C.go 然后 B.go、 然后是 A.go. 为了编译 A.go, 编译器读取的是 B.o 而不是 C.o. 这种机制对于编译大型的项目时可以显著地提升编译速度。 每一段代码只会被编译一次 一个 Go 程序是通过 import 关键字将一组包链接在一起。 import \"fmt\" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 \"\" 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。 如果需要多个包，它们可以被分别导入： import ( \"fmt\" \"os\" ) 该方法被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义 当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。 如果包名不是以 . 或 / 开头，如 \"fmt\" 或者 \"container/list\"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。 导入包即等同于包含了这个包的所有的代码对象。 除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。 包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件： 可见性规则 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是它们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。 （大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。 因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。 假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。 因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于它们的包名，例如 pack1.Thing 和 pack2.Thing。 你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：import fm \"fmt\"。下面的代码展示了如何使用包的别名： package main import fm \"fmt\" func main(){ fm.Println(\"hello, world\") } 注意：如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！”。 包的分级声明和初始化 你可以在使用 import 导入包之后定义或声明 0 个或多个常量 (const)、变量 (var) 和类型 (type)，这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用，然后声明一个或多个函数 (func)。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"2. 函数 这是定义一个函数最简单的格式： func functionName() 你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。 main() 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main() 函数，则会引发构建错误 undefined: main.main。main() 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main() 函数添加了参数或者返回类型，将会引发构建错误： func main must have no arguments and no return values results. 在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 main.main()，该函数一旦返回就表示程序已成功执行并立即退出。 函数里的代码（函数体）使用大括号 {} 括起来。 左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示： `build-error: syntax error: unexpected semicolon or newline before {` （这是因为编译器会产生 func main() ; 这样的结果，很明显这是错误的） Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误 右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行： func sum(a, b int) int { return a + b } 对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。 因此符合规范的函数一般写成如下的形式： func functionName(parameter_list) (return_value_list) { ... } 其中： parameter_list 的形式为 (param1 type1, param2 type2, …) return_value_list 的形式为 (ret1 type1, ret2 type2, …) 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。 下面这一行调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \\n： fmt.Println(\"hello, world\") 使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当被调用函数的代码执行到结束符 } 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。 程序正常退出的代码为 0 即 Program exited with code 0；如果程序因为异常而被终止，则会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"3. 注释 package main import \"fmt\" // Package implementing formatted I/O. func main(){ fmt.Printf(\"Καλημέρα κόσμε; or こんにちは 世界\\n\") } 上面这个例子通过打印 Καλημέρα κόσμε; or こんにちは 世界 展示了如何在 Go 中使用国际化字符，以及如何使用注释。 注释不会被编译，但可以通过 godoc 来使用。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可。当开发人员需要了解包的一些情况时，自然会用 godoc 来显示包的文档说明，在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起。另外，在多段注释之间应以空行分隔加以区分。 示例： // Package superman implements methods for saving the world. // // Experience has shown that a small number of procedures can prove // helpful when attempting to save the world. package superman 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 \"Abcd...\" 作为开头。 示例： // enterOrbit causes Superman to fly into low Earth orbit, a position // that presents several possibilities for planet salvation. func enterOrbit() error { ... } godoc 工具会收集这些注释并产生一个技术文档。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"4. go程序的一般结构 下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main() 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。 所有的结构将在本文或接下来的章节中进一步地解释说明，但总体思路如下： 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init() 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。 如果当前包是 main 包，则定义 main() 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main() 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 package main import ( \"fmt\" ) const c = \"C\" var v int = 5 type T struct{} func init() { // initialization of package } func main() { var a int Func1() // ... fmt.Println(a) } func (t T) Method1() { // ... } func Func1() { // exported function Func1 // ... } Go 程序的执行（程序启动）顺序如下： 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序（自下往上）在每个包中初始化常量和变量，如果该包含有 init() 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main() 函数开始执行程序。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"5. 命名规范 干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。 名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。 返回某个对象的函数或方法的名称一般都是使用名词，没有 Get... 之类的字符，如果是用于修改某个对象，则使用 SetName()。 有必须要的话可以使用大小写混合的方式，如 MixedCaps() 或 mixedCaps()，而不是使用下划线来分割多个名称。 ","date":"2023-02-04","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/:5:0","tags":["Golang语法基础"],"title":"Golang语法基础2-基本结构和语法","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95/"},{"categories":["编程技术"],"content":"1. 起源与发展 Go/Golang 起源于2007年，并于 2009 年正式对外发布，是一个完全开源的项目，背后的支持者是谷歌公司，它的主要目标是「兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性」。它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。 Go 的核心设计者是三位著名IT工程师：Ken Thompson，Rob Pike，Robert Griesemer。其中 Ken Thompson 是 Unix 操作系统的设计者，并因此获得图灵奖，也是 C 语言前身 B 语言的设计者，UTF-8 编码设计者之一，计算机史的重要人物，2006 年加入谷歌，和另外两人一起设计了 Go 语言。 Rob Pike 是 Ken 的老搭档。 随后又有 lan Lance Taylor 和 Russ Cox 两人加入团队，前者是 gccgo 编译器的作者和 cgo 工具链的维护者，后者加入团队后着手 Go 语言标准库的开发。 Go 语言以囊地鼠(Gopher)为图标和吉祥物，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。囊地鼠是一种原产于加拿大的啮齿类动物，Go 语言开发者也一般自称为 Gopher。 Go 语言相比于其它语言的最大优势在于它的执行性能与开发效率，这得益于 Go 在并发编程、内存回收等许多方面的良好设计，并因此大规模用于服务器编程、网络编程、数据库和云平台领域。 Go 是一种编译型的语言。它使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。 使用文本编辑器创建 Go 程序； 保存文件； 编译程序； 运行编译得到的可执行文件。 这不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤。Go 自带了编译器，因此无须单独安装编译器。 比较出名的 Go 语言项目有(不限于这些) Go语言本身： https://github.com/golang/go Docker： https://www.docker.com/ kubernetes： https://github.com/kubernetes/kubernetes Ethereum： https://github.com/ethereum/go-ethereum fabric： https://github.com/hyperledger/fabric Hugo： https://github.com/gohugoio/hugo TiDB： https://github.com/pingcap/tidb InfluxDB： https://github.com/influxdata/influxdb ETCD： https://github.com/etcd-io/etcd 使用 Go 的国外公司有：Google、Docker、NetFlix、CloudFlare、Dropbox、MongoDB、Uber等。 使用 Go 的国内公司有：七牛、字节跳动、bilibili、京东、百度、小米、腾讯、阿里等。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:1:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"2. 跟踪最新动态 最直接的方式是跟踪 Go 语言的源码库，关注提交历史和 issue 原始代码库： https://go.googlesource.com/go github镜像： https://github.com/golang/go 其它活跃论坛或动态 golang-dev：Google邮件列表的Go开发组讨论区 golang-nuts：Google邮件列表的Go讨论社区 golang-announce：发布Go版本或Go开发的最新状态 go.dev：2019.11.14上线的Go开发人员中心 gotime：Go的一个播客，每周一更，内容有干货 @golang：Go 语言在 Twitter 的官方帐号 Go 下载地址和相关的文档、标准库等访问地址为 官网 https://golang.org/ 国内的镜像网站 https://golang.google.cn/ Go语言中文网 是国内最活跃的Go社区，每周会发行一份 Go语言爱好者周刊 Go 相关资料聚集最多的还是 go wiki ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:2:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3. 下载安装 MacOS 下快速安装可以使用 Homebrew ，执行如下命令即可 $ brew install go 自动配置环境变量，安装完重启终端即可使用。 安装 Go 完成后，通过 brew list 查看，是否已安装成功。 用 go version 查看当前go的版本号。 需要升级 Go 语言版本的，输入以下命令： $ brew upgrade go 下面开始介绍常规的安装方法。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3.1 下载安装 Golang 中国官网下载页面为 golang.google.cn/dl，为 Windows、MacOS 和 Linux 三种环境都提供了安装包。 Windows 默认下载文件为 go1.20.windows-amd64.msi，双击启动即可安装，默认安装到Program Files 或Program Files (x86)。也可以根据需要更改位置。安装后，需要关闭并重新打开所有打开的命令提示符，以便安装程序对环境所做的更改反映在命令提示符中。环境变量将自动设置。但如果下载了以.zip为后缀的版本，则需要自己解压到合适的路径，并自己设置环境变量。 MacOS 默认下载文件为 go1.20.darwin-amd64.pkg，该软件包将 Go 发行版安装到 /usr/local/go。该包应将 /usr/local/go/bin 目录放入您的 PATH环境变量中。安装后，需要重新启动所有打开的终端会话才能使更改生效。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:1","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"3.2 配置 打开终端配置代理 go env -w GOPROXY=https://goproxy.cn,direct ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:3:2","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4. 编辑器/IDE Golang 开发最流行的两个工具是 Goland 和 VScode，我自己是 VScode 的使用者。除了这两个工具外，官方还提供了一份IDE和插件列表。 VScode 中的 Go 扩展提供了大量的特性，如自动补全、悬停信息显示、括号匹配等，原本属于第三方开发者维护，现在交给了 Go 团队。详细的特性说明查看官网或是VS Code 中的 Go 扩展 Github 项目，下面进行一些简单介绍。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:0","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.1 Go工具链 微软在开发 VS Code 过程中, 定义了一种协议： 语言服务器协议 ，用来为每种语言提供诸如自动完成，代码提示等功能。gopls 就是Go语言的服务器。 当在 VS Code 中编辑 Go 代码时如果没有安装，VScode 会在右下角弹出提示，只要直接点击 Install 即可，不需要自己输入命令。默认使用了 GOPATH 作为安装路径。 如果没有弹出，则在 VS Code 中安装 Go 扩展插件 shift+command+p 搜索 \u003eGo: Insatall/Update Tools 全选后确定 分别包括了以下 7 种工具： gotests # 测试工具，根据函数签名生成测试用例。 gomodifytags # 一个修改 Go 源代码文件中结构体字段标签的 Go 工具。 impl # 一个根据其使用情况生成接口方法存根的 Go 工具。 goplay # 一个在线实验 Go 代码的游乐场。 dlv # Go 语言的调试器，它允许开发人员暂停程序执行，检查变量的值，设置断点，以及执行其他调试操作。 staticcheck # 一个 Go 静态检查工具，对 Go 源代码执行各种检查，包括检测潜在错误、找到代码缓慢、不安全或过于复杂的代码。 gopls # Go 语言服务器是一个为各种文本编辑器和集成开发环境（IDE）提供语言特定功能的工具，例如代码导航、代码完成和诊断等。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:1","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.2 用户和工作区设置 使用 VS Code 需要关心的一个重要部分是用户和工作区设置，几乎所有的事情都和它们有关。 这是两种不同的设置范围 用户设置：是一个全局的设置，适用于打开的任何VScode窗口 工作区设置：是指项目工作区的设置，只适用于对应的工作区（譬如某个文件夹） 工作区的设置会覆盖掉用户设置，它针对具体的项目，配置文件位于项目根目录.vscode文件夹，可与其它开发者共享。.vscode文件夹还用于存放调试配置和任务配置。 点击左下角的齿轮，选择设置，默认的设置界面是一个可视化的界面，不过也可以使用settings.json配置文件 用户设置文件在 Windows 中位于 %APPDATA%\\Code\\User\\settings.json 用户设置文件在 MacOS 中位于 ~/Library/Application Support/Code/User/settings.json 工作区设置文件位于根目录的 .vscode 文件夹中 请注意，~ 表示用户主目录。因此，如果您的用户名是 “Cloud”，则该文件位于： /Users/Cloud/Library/Application Support/Code/User/settings.json 如果文件不存在，您可以打开 VSCode，单击文件菜单，然后单击首选项 \u003e 设置。您可以在此处编辑设置，VSCode 将自动创建该文件。 最后，VScode大量的操作都可以通过命令完成，使用快捷键Ctrl+Shift+P可以打开命令输入框。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:2","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.3 特性说明 在用户或工作区设置中，将 go.autocompleteUnimportedPackages 设为 true ，可以在代码中点击包名跳转查看包的具体内容。 鼠标悬停在变量、函数和结构体的名称上方可以查看它们的签名等信息，这一功能需要 godoc 或 gogetdoc 实现，通过在用户或工作区设置中调整 go.docsTool 来切换工具。 代码导航功能无需设置默认实现。 对源码的保存操作会自动触发格式化、编译和代码质量检查。格式化工具可以通过调整go.formatTool来设置。 编译的过程使用go build命令。 代码质量检查的工具为golint，也可以使用gometalinter，用来检查代码的规范性，检查得到的errors和warning会在编辑器里以红色/绿色波浪线标出来，下面的输出窗口也会显示详细信息。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:3","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"4.4 调试 调试使用的是前面安装的delve工具。在 VScode 中，按F5启动调试，一般情况下使用默认的调试配置即可，不过还是应当对调试配置选项有一定的了解。 具体调试方法可查看 Debugging Go code using VS Code，更多关于 VS Code 中 Go 调试的相关信息都可查看该文档。 运行程序使用快捷键Ctrl+F5，和调试使用的是同一个配置文件。 ","date":"2023-02-02","objectID":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/:4:4","tags":["Golang语法基础"],"title":"Golang语法基础1-背景与初探","uri":"/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%88%9D%E6%8E%A2/"},{"categories":["编程技术"],"content":"本系列主要介绍数据库和 SQL 的基础知识，使用的教材是SQL必知必会。 数据库(database)是保存有组织的数据的容器（通常是一个文件或一组文件）。简单来说，数据库是一个用于存储大量数据的系统。它允许你快速地存储、检索和更新数据。这些数据可以是客户信息、销售数据、财务数据等。 数据库又可根据数据的存储方式分成不同的种类，例如： 关系数据库（例如：MySQL、Oracle、SQL Server） 非关系数据库（例如：MongoDB、Redis） SQL (Structured Query Language:结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。 人们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统(DBMS) 数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:0:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"1. 关系型数据库 关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库是由多张能互相连接的表组成的数据库。 你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了的，而是先准备好一个资料袋，然后将相关的资料放入特定的资料袋中。在数据库领域中，这种资料袋称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。 优点 都是使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 数据存储在磁盘中，安全。 缺点 读写性能比较差，不能满足海量数据的高效率读写。 不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。 固定的表结构，灵活度较低。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:1:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"2. 非关系数据库（NoSQL） 非关系型数据库被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 优点 非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。 海量数据的维护和处理非常轻松。 非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。 可以实现数据的分布式处理。 缺点 非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。 非关系数据库没有事务处理，没有保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。 功能没有关系型数据库完善。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:2:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"3. MySQL 为了更好地应用SQL，我们需要安装一个MySQL便于学习过程中进行练习。 MySQL 是最流行的数据库之一，是一个免费开源的关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 适合中小型软件，被个人用户以及中小企业青睐。 针对不同的用户，MySQL 分为两个版本： MySQL Community Server（社区版）：该版本是自由下载且完全免费的，但是官方不提供技术支持。 MySQL Enterprise Server（企业版）：该版本是收费的，而且不能下载，但是该版本拥有完善的技术支持 MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20： 第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。 第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。 第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。 MySQL 的主要特点就是免费，并且在任何平台上都能使用，占用空间相对较小。 MySQL 是 C/S 架构，有 Client 和 Server 两部分，可以都安装在一台电脑上，也可以独立安装。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:3:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"4. 安装与配置 官方下载页面：https://dev.mysql.com/downloads/ MacOS安装可参考这个视频： ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:4:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"5. 图形化管理工具 常用的图形化管理工具有 MySQL Workbench 和 Navicat，前者是官方提供的工具，但后者比较好用。 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:5:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"6. SQL 对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。SQL包括四部分 数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令：- SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 我们将在接下来的几篇文章中学习它们。 SQL 的几个易错书写规则如下 以分号 ; 结尾 SQL 语句不区分大小写 单词需要半角空格或换行来分隔 ","date":"2023-02-01","objectID":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/:6:0","tags":["数据库"],"title":"SQL学习1-入门","uri":"/sql%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8/"},{"categories":["编程技术"],"content":"Hugo 是由 Go 语言实现的静态网站生成器，可以快速建立一个静态网站，虽然多数情况下用来搭建个人博客，但也可以用作展示在线书籍、个人简历等。 最早我也是使用 Hugo 搭建的个人博客，由于之前才疏学浅，我所使用的博客出现了一些 bug，我无法修复，因此也很久没有更新过文章。借着 2023 年的春节，我重新搭建了这个博客。其中很多细节已经忘记了，因此耗费了我不少时间，为了节约精力，因而有了这篇文章小记，方便自己以及后人。 本文用来记录 Hugo 使用种遇到的问题和积累的经验。本文是第一篇（也许也是最后一篇），介绍博客网站搭建的过程和一些基础配置。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"1. 安装Hugo 安装Hugo前请确保您的电脑上已安装了 Git 和 Go 。 详细的安装说明参见官方文档，这里简单介绍 MacOS 的快速安装。 MacOS 下可自行从官网下载软件包安装，也可以使用 Homebrew 包管理工具快速安装 # 更新homebrew到最新 % brew update # 安装hugo（用homebrew默认安装扩展版本） % brew install hugo # 检查安装 % brew list 注意要安装 extended 版本，主要是因为很多主题都需要扩展版的功能，如果确认自己的主题不需要(阅读主题说明)，可以按照正常的版本。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"2. 生成博客网站 执行下面的命令在本地生成博客网站项目文件夹，该文件夹是这一系列文章之后所有操作执行的根目录(简称为项目根目录)，我建立的项目文件夹名为 cloud1998.github.io （因为之后要使用 Github Pages 托管博客）。 % hugo new site cloud1998.github.io % cd cloud1998.github.io blog 文件夹的目录结构如下所示： % ls config.toml layouts static archetypes content themes assets data resources 其中： config.toml 是博客的配置文件 content 是博客文章存放的地方 themes 是博客主题目录 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"3. 安装主题 Hugo没有默认主题，需要自己从官方的主题列表下载安装。其中 LoveIt 是我喜欢的主题。因为主题通常是单独的 Github 仓库，因此将其作为博客项目的子模块进行管理。 # 初始化项目目录为 git 仓库 git init # 将主题项目作为子模块添加 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 复制主题提供的站点配置文件 config.toml 到项目根目录，覆盖 Hugo 本身的站点配置文件。 请打开下面的代码块查看完整的配置⬇️： baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"我的网站\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"这是我的全新 Hugo 网站\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"我的网站\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4. 网站配置 正式使用前，我们需要编辑站点配置文件从而设置网站的一些内容，上面的配置文件已经进行了详细的说明，如有更多疑问请查阅LoveIt官方主题文档。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4.1 头像 新建static/images文件夹，将头像文件 avatar.png 存放在这里。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:1","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"4.2 网站图标 使用 favicon generator 生成配套的网站图标，放到 /static 目录下，可以设置网站在各平台的显示图标，包括如下内容 android-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml cover.png favicon.ico favicon-16x16.png favicon-32x32.png logo.png mstile-150x150.png safari-pinned-tab.svg site.webmanifest 然后修改站点配置文件中的配置项即可。 更多配置可以参考Mogeko的个人博客 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:2","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5. 托管到Github 将本地的所有项目文件提交到本地仓库中。 % git add . % git commit -m \"Initial commit\" 浏览器打开 Github 网站，创建和项目文件夹同名的仓库，该仓库用于存储项目文件夹下所有内容。创建完成后，在本地项目根目录，执行下列命令，将项目文件推送到远程仓库。 % git remote add origin https://github.com/cloud1998/cloud1998.github.io.git % git push -u origin main 关于网页如何托管在Github的详细说明可以参考Host on Github ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5.1 源码备份 按照 Hugo 的生成规则，执行 hugo 命令后，网站静态文件将会生成在 public 文件夹。但由于我们使用 Github Pages 托管博客网站，该功能启用后 Github 仓库只会从 main branch 或 main branch 中的 /docs 目录下读取网站源码。 我们解决这一问题的方法是新建 blog 分支将博客源码放在该分支下，利用 Github Action 自动根据 blog 分支的博客源码执行 hugo 命令，并将生成的结果推送到 main 分支。首先在本地项目根目录下执行下列命令新建并切换到 blog 分支。 注：Github Action 的说明见附录I % git checkout -b blog % git branch * blog main # 将新分支推送到远程仓库 并建立跟踪关系 % git push -u origin blog 在使用 “git push” 时，第一次推送新分支时，需要使用 “–set-upstream” 或 “-u” 选项，以便在远程仓库中设置跟踪关系。 将本地 blog 分支的内容推送到远程仓库后，在网页端进入cloud1998.github.io仓库的设置页面，将默认分支设置为 blog 分支。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:1","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"5.2 推送到main分支 首先生成公私钥供 Github Action 使用 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f blog -N \"\" # You will get 2 files in current file: # blog.pub (public key) # blog (private key) 然后进入 cloud1998.github.io 仓库设置页面，在 Deploy Keys 中添加公钥，在 Secrets 中添加私钥，私钥名设置为 ACTIONS_DEPLOY_KEY 接着新建 YAML 配置文件，Github Action 要求配置文件位于 .github/workflows 目录下，新建完成后目录结构如下 $ ls ./.github/workflows main.yml Github Action使用一种模块化的思路，即将很多持续集成的操作写成独立的脚本文件，放到代码仓库，让其它开发者使用。因此进行持续集成时，可以直接引用别人写好的 action，整个持续集成的过程，就是一个 actions 组合的过程。GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 我们的基本思路如下 整个流程在 blog 分支 push 时触发 只有一个job，运行在ubuntu-20.04环境下 使用官方提供的 action/checkout 获取仓库源码，注意添加参数clone主题子模块 使用 peaceiris/actions-hugo: GitHub Actions for Hugo 部署 hugo 环境，注意使用 extentded 版本（主题要求） 直接执行 hugo 命令 使用 peaceiris/actions-gh-pages 将执行的结果部署到GitHub Pages的源目录，默认即main分支的目录下。 完整的main.yml脚本内容如下 name:hugopushtogithubpageson:push:branches:- blogjobs:build-deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v1with:submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.63.2'extended:true- name:Buildrun:HUGO_ENV=productionhugo--gc--minify- name:Deployuses:peaceiris/actions-gh-pages@v2env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}PUBLISH_BRANCH:mainPUBLISH_DIR:./public 保存上面的文件后，将本地仓库推送到远程，Github 检测到 .github/workflow 目录和里面的main.yml 文件，就会自动运行，在网页端可以查看运行日志，如果出现错误可以根据日志内容就行修改。 等到 workflow 运行结束，访问博客页面，就可以看到更新成功了。切换到 main 分支，也可以看到推送的网页文件，不过因为设置了默认分支为 blog，以后打开网页端该仓库，以及在本地 clone 的时候，默认都是 blog 分支。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:2","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"6. 文章发布 在 content 目录下创建 posts文件夹，写作的文章全部放到该目录下，在每篇文章开头添加元数据字段，可以是YAML或TOML格式，示例如下 title = \"Getting Started with Hugo\" description = \"\" type = [\"posts\",\"post\"] tags = [ \"go\", \"golang\", \"hugo\", \"development\", ] date = \"2014-04-02\" categories = [ \"Development\", \"golang\", ] series = [\"Hugo 101\"] [ author ] name = \"Hugo Authors\" 下面是一篇示例文章 --- title: 示例文章 date: 2023-01-30 tags: [\"博客搭建\"] categories: [\"编程技术\"] --- 这是一篇示例文章。 文章保存后将仓库新增内容推送到远程仓库： % git add . % git commit -m \"更新了一篇文章\" % git push 几分钟后即可在 https://cloud1998.github.io 看到这篇文章。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["编程技术"],"content":"附录I Github Action GitHub Actions 是 GitHub 在2018年10月推出的一个持续集成服务，之前一直是试用阶段，2019年末开放，据说比Travis CI 更简单更好用。 Github Actions入门可以阅读官方文档或者阮一峰大神的GitHub Actions 入门教程。 ","date":"2023-01-30","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["博客搭建"],"title":"hugo搭建个人博客1-基础建站","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"这是我的第一篇hugo文章。 ","date":"2023-01-29","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"我们已经在一起 var countDownDate=new Date(\"2022-09-28T19:40:00\").getTime();window.setInterval(function(){var e=(new Date).getTime()-countDownDate,t=Math.floor(e/(1e3*60*60*24)),n=Math.floor(e%(1e3*60*60*24)/(1e3*60*60)),s=Math.floor(e%(1e3*60*60)/(1e3*60)),o=Math.floor(e%(1e3*60)/1e3);document.getElementById(\"since\").innerHTML=t+\" 天 \"+n+\" 时 \"+s+\" 分 \"+o+\" 秒\"},1e3) ","date":"2022-09-28","objectID":"/since/:0:1","tags":null,"title":"Since 2022/09/28","uri":"/since/"},{"categories":null,"content":"关于网站 | 个人博客，欢迎交流 ","date":"2022-02-03","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者 ❤️ 爱好游戏、电影 ","date":"2022-02-03","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]